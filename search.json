[{"categories":null,"content":"This is the home of my blog!\n","description":"","tags":null,"title":"Home","uri":"/"},{"categories":null,"content":"Tentang diri anda\n","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":["emacs"],"content":"First heading within the post  This post will be exported as content/posts/writing-hugo-blog-in-org-subtree-export.md. Its title will be “Writing Hugo blog in Org”. It will have hugo and org tags and emacs as category. The menu item weight and post weight are auto-calculated. The menu item identifier is auto-set. The lastmod property in the front-matter is set automatically to the time of export.  A sub-heading under that heading  It’s draft state will be marked as true as the subtree has the todo state set to TODO.    With the point anywhere in this Writing Hugo blog in Org post subtree, do C-c C-e H H to export just this post.\nThe exported Markdown has a little comment footer as set in the Local Variables section\nKeep on testing Just keep on testing\n","description":"","tags":["hugo","org"],"title":"Writing Hugo blog in Org","uri":"/posts/hugo-blog-in-org-subtree-export/"},{"categories":["programming"],"content":"There are various ways to organise your R workflow. If you are working with a big project, then Airflow might be for you. But for the majority of R project codes, drake package will fullfilled your need.\nHere is the basic use of drake. The example here will be using a simple collections of functions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  fun1 \u003c- function(x = globalenv()$x){ x + 2 } fun2 \u003c- function(i = 3){ i * 10 } fun3 \u003c- function(){ x1 = fun1() x2 = fun2(5) x1 + x2 } fun4 \u003c- function(z = globalenv()$z){ x1 = 1 + z x2 = fun2(2) x3 = fun3() x1 + x2 + x3 }   Install drake development version in Github here.\n1 2 3 4 5 6 7 8 9 10 11  remotes::install_github(\"ropensci/drake\") library(drake) x = 3 z = 5 plan \u003c- drake_plan( output = fun4() ) make(plan)   Running make(plan) will give the overview what is in the plan, sort of like using Make.\n1 2 3  ▶ target x ▶ target z ▶ target output   Then you can make the interactive network to see all the workflow. This can be done several ways.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  library(\"visNetwork\") vis_drake_graph(plan, full_legend = TRUE) ## need networkD3 package library(networkD3) sankey_drake_graph(plan) library(ggraph) drake_ggraph(plan) ## To show only target and dependency plot(plan) ## read the build target readd(output)   This how it looks like using vis_drake_graph. For interactive can be seen here.\n  ","description":"","tags":["R","drake"],"title":"Basic use of drake","uri":"/posts/basic-drake/"},{"categories":["Git"],"content":"This is just 100% a copy from gist so I can check it when needed.\nSo you’ve cloned somebody’s repo from github, but now you want to fork it and contribute back. Never fear!\nTechnically, when you fork “origin” should be your fork and “upstream” should be the project you forked; however, if you’re willing to break this convention then it’s easy.\nOff the top of my head\n Fork their repo on Github In your local, add a new remote to your fork; then fetch it, and push your changes up to it   1 2 3  git remote add my-fork git@github...my-fork.git git fetch my-fork git push my-fork   Otherwise, if you want to follow convention:\n Fork their repo on Github In your local, rename your origin remote to upstream   1  git remote rename origin upstream    Add a new origin   1  git remote add origin git@github...my-fork    Fetch \u0026 push   1 2  git fetch origin git push origin   ","description":"","tags":["fork"],"title":"git fork","uri":"/posts/git-fork/"},{"categories":["bash"],"content":" Table of Contents  Ubuntu Windows    Bila ingin memakai program di Ubuntu atau Windows melalui terminal, perlu daftarkan program tersebut di PATH. Disini saya terangkan caranya di Ubuntu dan Windows.\nUbuntu Bila pasang program di Ubuntu melalui source boleh tetapkan dimana program disimpan melalui penetapkan --prefix bila melarikan ./configure. Cara biasa bila pasang program dari source ialah:\n1 2 3  ./configure make make install   Bila ./configure tidak menetapkan prefix secara tidak langsung komando yang dipakai ialah ./configure --prefix=/usr/local dimana folder /usr/local dipakai untuk menyimpan fail-fail berkaitan program yang dipasang. Biasanya fail untuk larikan program akan disimpan seterusnya di folder bin, libraries di folder lib, manual di folder man dan seterusnya.\nUntuk tetapkan folder semasa memasng program dari source boleh buat begini:\n1 2 3  ./configure --prefix=$HOME/local # atau ./configure --prefix=/home/ybk   Bila menetapkan prefix selain dari /usr/local seperti di atas, perlu tetapkan folder tersebut di $PATH agar Ubuntu dapat melarikan program yang ingin dipakai. Untuk periksa folder-folder yang sudah ditetapkan boleh pakai:\n1  \u003e echo $PATH   1  /home/ybk/.local/bin:/home/ybk/bin:/home/ybk/.local/bin:/usr/local/games:/snap/bin:/usr/local/stata   Penetapan folder di $PATH boleh dibuat dengan cara di bawah. Cara ini akan memasukkan PATH di fail /.profile atau /.bashrc.\n1  \u003e export PATH=\"$PATH:/path/folder\"   Bila melarikan komando export penetapan di $PATH hanya sementara dan hilang bila mematikan komputer. Untuk memasukan folder yang ditetapkan di --prefix ke $PATH selama-lamanya, harus larikan:\n1 2 3  source ~/.profile # atau source ~/.bashrc   Sekiranya tidak menetapkan di $PATH boleh juga menggunakan symlink\n1  sudo ln -s /path/ke/folder/baru/ ~/bin   Windows Cara daftarkan PATH untuk .exe program bergantung samada kita memiliki administrator right atau tidak. Cara yang ditunjukkan disini ialah disituasi tanpa admin right.\nKita boleh lihat semua program-program yang didaftarkan di PATH dengan melarikan arahan di bawah di power shell atau terminal:\n1  echo %PATH%   Sekiranya tidak pasti bagimana untuk membuka terminal, tulis di search samada cmd atau powershell.\nKemudian buka control panel [kontrolpanel] \u003e user [brukerkontoer] \u003e environment variable [miljøvariablene]\nWindow baru akan dibuka dan pilih Variable \u003e Path \u003e edit \u003e new.\nMasukkan path program yang menggandungi .exe. Penting tidak memasukkan nama fail .exe, cuma path ke fail tersebut sahaja. Contohnya:\n1  C:\\Program Files\\R\\R-4.0.0\\bin   ","description":"","tags":["ubuntu","windows"],"title":"Tetapkan PATH","uri":"/posts/tetapkan-path/"},{"categories":["plot"],"content":" Table of Contents  Susun ketinggian bar Nama di aksis    Bila buat bar plot cara asas di R atau menggunakan pakej ggplot2, susunan levels di x-aksis disusun semula menggikut abjad. Oleh sebab itu sekiranya ingin menyusun mengikut aturcara tertentu, levels di x-aksis harus disusun semula. Pelbagai cara untuk menyusun variable boleh dibuat contohnya menggunakan order (dari “base”) dan reorder (dari “stat”). Kedua-dua fungsi ini sudah tersedia di R tanpa perlu memuat turun sebarang pakej.\nCara reorder adalah yang paling mudah tetapi agak lambat berbanding order sekiranya ingin dipakai untuk fungsi di Big Data.\nUntuk memakai cara order dari “base”. Dengan menggunakan with akan lebih mempercepatkan proses:\nSusun ketinggian bar Cara untuk menyusun bar menaik atau menurun\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  ## data data \u003c- data.frame(a = LETTERS[1:10], b = rnorm(10, mean = 30, sd = 5), c = runif(10, 10, 50), d = letters[1:10], e = sample(1:100, size = 10, replace = FALSE)) ## susun \"a\" mengikut nilai \"b\" menaik data$a \u003c- factor(data$a, levels = data$a[order(data$b)]) ## susun \"a\" mengikut nilai \"b\" menurun data$a \u003c- factor(data$a, levels = data$a[order(data$b, decreasing = TRUE)]) ## Buat plot library(ggplot2) data2 \u003c- copy(data) ggplot(data2, aes(a, b)) + geom_bar(stat = 'identity')     Bila menggunakan with, penulisan kode juga akan lebih mudah. Contohnya:\n1  data$d \u003c- with(data2, factor(d, levels = d[order(e, decreasing = FALSE)]))   Nama di aksis Sekiranya ingin menyusun x-aksis mengikut cara lain selain dari nilai menurun atau menaik melalui pilihan decreasing = TRUE, boleh juga menetapkan susunan cara manual. Bila memakai cara ini harus memberikan nama susunan dengan tepat seperti nama di variable.\n1 2 3 4 5 6  ## contoh data data3 \u003c- data.frame(a = LETTERS[1:4], b = sample(20:50, size = 4)) ## Susun cara sendiri data3$a \u003c- factor(data3$a, levels = c(\"B\", \"D\", \"A\", \"C\")) ## plot ggplot(data3, aes(a, b)) + geom_bar(stat = 'identity')     Untuk memakai cara reorder dari “stat”:\n1 2  ## pakai data sama seperti di atas cumpa pakai factor \"d\" dan nilai \"e\" data$d \u003c- reorder(data$d, data$e)   Cara lain untuk menyusun semula faktor variable menggikut susunan tertentu boleh juga dilaksanakan dengan menggunakan fungsi fct_reorder atau fct_reorder2 dari pakej fotcats yang boleh dibaca di sini. Pakej ini juga ialah sebahagian daripada pakej tidyverse yang mengandungi pakej-pakej lain seperti dplyr dan ggplot2.\n","description":"","tags":null,"title":"Susun factor","uri":"/posts/susun-factor/"},{"categories":["DT"],"content":" Table of Contents  .N Mult .SD dan .SDcols .I .GRP dan rleid Contoh dari manual    Hari ni bersempena Hari kemerdekaan Malaysia ada masa untuk ulang kaji pakej data.table. Hari ni ialah mengenai Special Symbol seperti .N, .I, .GRP, .BY. Penerangan ini diambil dari manual di data.table tetapi diedit sedikit. Untuk rujukan di sini.\nIni data yang dipakai untuk membuat contoh:\n1 2  DT = data.table(x=rep(c(\"b\",\"a\",\"c\"),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,6,3,7,8), a=1:9, b=9:1) X = data.table(x=c(\"c\",\"b\"), v=8:7, foo=c(4,2))   .N Penggunaan .N selain dari untuk mendapatkan jumlah baris di dataset, .N boleh juga digunakan untuk melihat barisan terakhir di dataset. Untuk melihat barisan pertama guna DT[1].\n1 2 3  DT[.N] # last row, only special symbol allowed in 'i' - nesten som Total DT[, .N] # total number of rows in DT DT[, .N, by=x] # number of rows in each group   Mult Contoh untuk penggunaan mult (multiple rows) adalah seperti di bawah. Penggunaan fungsi mult ialah untuk menetapkan kombinasi barisan yang ingin ditunjukkan samada “all”, “first” atau “last”. Variable x dan y boleh disusun dengan menggunakan setkey(DT, x, y). Sekiranya tidak disusun terlebih dahulu sebelum dipakai maka harus menggunakan fungsi on seperti contoh di bawah.\n1 2 3 4 5 6 7 8 9 10 11  ## contoh data dt \u003c- data.table(x = c(1, 1, 3, 1, 7), y = c(1, 2, 3, 2, 6)) setkey(dt, x) ## dapatkan kombinasi yang unik udt \u003c- unique(dt) ## buat kolom dengan nilai 0 dt[, c(\"first\", \"last\") := 0L][]   1 2 3 4 5 6  x y first last 1: 1 1 0 0 2: 1 2 0 0 3: 1 2 0 0 4: 3 3 0 0 5: 7 6 0 0   Menggunakan mult untuk menetapkan kombinasi unik yang diingini. Pemakaian \"first\" menunjukkan kombinasi pertama sahaja. Sekiranya kombinasi yang sama terdapat dipelbagai baris, hanya barisan yang pertama dimana kombinasi tersebut ditemui akan dipilih. Pemakaian \"last\" memilih barisan terakhir dimana kombinasi yang diingini ditemui.\n1 2 3 4 5 6 7  ## Sekiranya kombinasi x,y yang pertama terdapat ## di data masukkan 1 di kolom \"first\" dt[udt, first := 1L, on = c(\"x\", \"y\"), mult = \"first\"][] ## Sekiranya kombinasi x,y yang terakhir terdapat ## di data masukkan nilai 1 di kolom \"last\" dt[udt, last := 1L, on = c(\"x\", \"y\"), mult = \"last\"][]   1 2 3 4 5 6  x y first last 1: 1 1 1 1 2: 1 2 1 0 3: 3 3 1 1 4: 1 2 0 1 5: 7 6 1 1   Contoh di bawah menunjukkan cara sekiranya hanya ingin mendapatkan index kombinasi yang diingini sahaja.\n1 2 3 4  ## Untuk lihat indeks bagi kombinasi yang unik sahaja dt[unique(dt), on = c(\"x\", \"y\"), mult = \"first\", which = TRUE] [1] 1 2 3 5   Contoh lain menggunakan mult. Seperti kajian isi rumah (household) dimana “id” mewakili rumah. Semua ahli keluarga mempunyai id-rumah sama. Sekiranya ingin mencari ahli termuda atau tertua fungsi mult dapat memudahkan proses.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  set.seed(1234) dt \u003c- data.table(id = sample(1:4, 10, TRUE), umur = sample(20:35, 10, TRUE), jentina = sample(1:2, 10, TRUE), kode = sample(1:5, 2, TRUE)) ## Susun umur mengikut id setkey(dt, id, umur) ## first ialah id yang sama ahli yang paling muda dt[unique(dt), muda := 1L, on = list(id), mult = \"first\"][] ## Pilih yang terakhir dari id yang sama - cth utk pilih ahli tertua ## sekiranya tidak pakai list di 'on = list(nama-var)' boleh pakai \"nama-var\". dt[unique(dt), tua := as.integer(1L), on = \"id\", mult = \"last\", by = .(umur)][] ## pilih nilai pertama untuk setiap kombinasi unik antara 'id' dan 'kode' dt[unique(dt[, c(\"id\", \"kode\")]), KodePertama := 1L, on = list(id, kode), mult = \"first\"][] ## pilih nilai terakhir untuk setiap kombinasi unik antara 'id' dan 'kode' dt[unique(dt[, c(\"id\", \"kode\")]), KodeAkhir := 1L, on = c(\"id\", \"kode\"), mult = \"last\"][]   Hasilnya dari contoh pemilihan ahli yang paling muda dan tua dari data di atas menggunakan \"first\" dan \"last\". Pemakaian unique(dt) berasaskan dari penetapan yang dibuat di fungsi setkey dimana data disusun mengikut id kemudian umur terlebih dahulu.\nSekiranya pemilihan kombinasi unik berasaskan kolom lain, selain dari id dan umur yang telah ditetapkan, pemilihan kolom unik boleh dibuat secara fungsi asas menggunakan unique(dt[, c(\"kol1\", \"kol2\")]). Penggunaan on boleh memakai cara list atau concatenate.\n1 2 3 4 5 6 7 8 9 10 11  id umur jentina kode muda tua KodePertama KodeAkhir 1: 1 24 2 3 1 NA 1 NA 2: 1 24 2 2 NA NA 1 1 3: 1 31 1 3 NA 1 NA 1 4: 3 22 2 3 1 NA 1 NA 5: 3 23 1 2 NA NA 1 NA 6: 3 24 1 3 NA NA NA 1 7: 3 28 1 2 NA NA NA NA 8: 3 33 2 2 NA NA NA NA 9: 3 34 1 2 NA 1 NA 1 10: 4 24 1 3 1 1 1 1   .SD dan .SDcols Penggunaan .SD juga boleh berasaskan indeks barisan. Contoh untuk menggunakan .SDcols seperti di bawah termasuk menggunakan fungsi lapply. Tetapi penggunaan \".SD\" adalah lebih lambat berbanding menggunakan fungsi \"on\" seperti di atas.\n1 2 3 4 5 6 7 8 9 10  # pilih kolom 'x' dan 'y' DT[, .SD, .SDcols = x:y] # baris pertama di semua kolom DT[, .SD[1]] # baris pertama di 'y' dan 'v' untuk setiap kumpulan di 'x' DT[, .SD[1], by = x] # get rows *and* sum all col DT[, c(.N, lapply(.SD, sum)), by = x] # get rows *and* sum columns 'v' and 'y' by group DT[, c(.N, lapply(.SD, sum)), by = x, .SDcol = c(\"v\", \"y\")]   .I Untuk dapatkan indeks barisan simbol .I boleh dipakai. Hanya vektor untuk indeks barisan yang akan diberikan dan tidak nilai di indeks tersebut. Fungsinya sama seperti seq_len(nrow(x)). Semasa penggumpulan dibuat, pada masa yang sama penggumpulan dilakukan di dalam kumpulan yang ditetapkan. Sesuai digunakan untuk membuat subset di j seperti: DT[,.I[which.max(somecol)], by=grp]. Penggunaannya same seperti fungsi which di base.\nCara lain boleh digunakan untuk membuat indentity atau ID. DT[, id := .I] seperti menggunakan DT[, id := seq_len(.N)\nPemakaian .I[1] contohny digunakan untuk mendapatkan index dimana nilai pertama bagi setiap kumpulan di x. Untuk kumpulan b di kolom x, nilai pertama ialah di barisan 1, nilai pertama bagi kumpulan a di kolom x ialah di barian ke 4 dan nilai pertama kumpulan c di barisan ke 7.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  DT x v y a b 1: b 1 1 1 9 2: b 1 6 2 8 3: b 1 3 3 7 4: a 2 7 4 6 5: a 2 8 5 5 6: a 1 1 6 4 7: c 1 6 7 3 8: c 2 3 8 2 9: c 2 7 9 1 DT[, .I[1], by = x] # first row number in DT corresponding to each group x V1 1: b 1 2: a 4 3: c 7 DT[, .(index = .I[1]), by = x] # Namakan variable untuk index x index 1: 1 1 2: 3 4 3: 7 5   Untuk dapatkan index bagi nilai maksimum mengikut kumpulan di kolom x boleh dibuat seperti cara di bawah.\n1 2 3 4 5 6  DT[, .I[which.max(y)], by = x] # which row number with the max 'y' by 'x' x V1 1: b 2 2: a 5 3: c 9   .GRP dan rleid Untuk mengkaji menggikut kumpulan secara penyusunan.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  DT[, grp := .GRP, by = x][] # add a group counter x v y a b grp 1: b 1 1 1 9 1 2: b 1 6 2 8 1 3: b 1 3 3 7 1 4: a 2 7 4 6 2 5: a 2 8 5 5 2 6: a 1 1 6 4 2 7: c 1 6 7 3 3 8: c 2 3 8 2 3 9: c 2 7 9 1 3 DT[, .N, by = rleid(v)] # get count of consecutive runs of 'v' rleid N 1: 1 3 2: 2 2 3: 3 2 4: 4 2 DT[, c(.(ym = max(y)), lapply(.SD, min)), by = rleid(v), .SDcols = v:b] # compute 'j' for each consecutive runs of 'v' rleid ym v y a b 1: 1 6 1 1 1 7 2: 2 8 2 7 4 5 3: 3 6 1 1 6 3 4: 4 7 2 3 8 1   Untuk gabungkan dua dataset. Tapi cara ini masih tidak difahami :-(\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  X x v foo 1: c 8 4 2: b 7 2 ## need more info for this X[, DT[.BY, y, on = \"x\"], by = x] # join within each group x V1 1: c 6 2: c 3 3: c 7 4: b 1 5: b 6 6: b 3   Untuk tukar nilai bagi setiap barisan pertama di kumpulan yang sama. Ini biasanya dipakai contohnya bila membuat kajian keluarga dan ingin memberikan kod tertentu yang membezakan keluarga 1 dan 2 dsb.\nCara ini tidak hard code data. Kolom c tidak dimasukkan ke data dan hanya disimpan di memory sahaja. Untuk simpan harus assign to save object atau gunakan cara mult.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  ## Recode to 99 for first row in each group by x DT[, {vDT = copy(.SD) #kopi semua kolom vDT[1, c := 99] #buat kolom C row pertama nilai 99 vDT}, by = x] x v y a b grp c 1: b 1 1 1 9 1 99 2: b 1 6 2 8 1 NA 3: b 1 3 3 7 1 NA 4: a 2 7 4 6 2 99 5: a 2 8 5 5 2 NA 6: a 1 1 6 4 2 NA 7: c 1 6 7 3 3 99 8: c 2 3 8 2 3 NA 9: c 2 7 9 1 3 NA DT[unique(x), d:=99, on = \"x\", mult = \"first\"][]   Contoh dari manual Ini ialah contoh dan penerangan dari manual sekiranya penerangan diatas tidak difahami.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  ## Not run: DT = data.table(x=rep(c(\"b\",\"a\",\"c\"),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT X = data.table(x=c(\"c\",\"b\"), v=8:7, foo=c(4,2)) X DT[.N] # last row, only special symbol allowed in 'i' DT[, .N] # total number of rows in DT DT[, .N, by=x] # number of rows in each group DT[, .SD, .SDcols=x:y] # select columns 'x' and 'y' DT[, .SD[1]] # first row of all columns DT[, .SD[1], by=x] # first row of 'y' and 'v' for each group in 'x' DT[, c(.N, lapply(.SD, sum)), by=x] # get rows *and* sum all columns by group DT[, .I[1], by=x] # row number in DT corresponding to each group starting point DT[, .N, by=rleid(v)] # get count of consecutive runs of 'v' DT[, c(.(y=max(y)), lapply(.SD, min)), by=rleid(v), .SDcols=v:b] # compute 'j' for each consecutive runs of 'v' DT[, grp := .GRP, by=x] # add a group counter X[, DT[.BY, y, on=\"x\"], by=x] # join within each group ## End(Not run)   ","description":"","tags":["R"],"title":"special symbol","uri":"/posts/dt-special-symbol/"},{"categories":["DT"],"content":"Percobaan untuk memasukkan gambar di post dan penetapan size.\n  ","description":"","tags":null,"title":"Test figure","uri":"/posts/test-figure/"},{"categories":["R"],"content":"Lookup table dipakai untuk mempercepatkan proses dan mengelakkan pemakaian ifelse. Untuk mempercepatkan proses, ordered index untuk data.table harus dipakai.\nCara 1 Kode ini dipakai sekiranya ingin mendapakan nilai di lookup tabel yang berhampiran. Contohnya nilai 1.3730682 adalah berhampiran dengan nilai 1.35.\n1  setDT(df1)[, ScoreLU := setDT(df2)[df1, ScoreLU , on = \"DSCRpd\", roll = \"nearest\"]]   Hasilnya seperti begini:\n1 2 3 4 5 6 7 8 9 10 11  DSCRpd Leverage TCB ScoreLU 1: 1.3730682 2.010122 -1590099.11 60 2: 1.0449597 2.680051 493370.85 30 3: 1.0311141 4.790531 21594.63 30 4: 1.3923007 3.279903 -499326.76 60 5: 1.6443938 3.853003 988780.79 70 6: 0.6265976 1.814359 1003736.73 0 7: 2.1025253 4.412528 1245305.83 80 8: 1.2872873 2.074424 -688305.83 50 9: 0.5088294 2.504510 1406986.68 0 10: 1.7794307 3.724905 1132513.33 70   Cara ini ialah untuk mendapakan nilai ScoreLU yang terdapat di data ScoreLU melalui kolom kekunci DSCRpd dikedua-dua data.table. Sekiranya nilai di DSCRpd di df1 tidak sama dengan ScoreLU, kekunci yang berhampiran dirujuk untuk mendapatkan nilai ScoreLU. Contohnya:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  df1 DSCRpd Leverage TCB 1 1.3730682 2.010122 -1590099.11 2 1.0449597 2.680051 493370.85 3 1.0311141 4.790531 21594.63 4 1.3923007 3.279903 -499326.76 ScoreLU ScoreLU DSCRpd Leverage TCB 1: 0 0.65 5.0 0 2: 10 0.80 4.5 100000 3: 20 0.95 4.0 250000 4: 30 1.10 3.5 500000 5: 40 1.20 3.0 850000 6: 50 1.26 2.5 1250000 7: 60 1.35 2.0 1700000   Untuk dapatkan nilai ScoreLU bagi kekunci DSCRpd 1.3730682 di df1 ialah 60 kerana nilai DSCRpd yang berhapiran di data ScoreLU ialah 1.35.\nCara 2 Cara ini sama seperti di atas cuma diterangkan secara mudah. Untuk menunjukkan cara ini kita buatkan data sebagai contoh:\n1 2 3  DT \u003c- data.table(V1=c(0L,1L,2L), V2=LETTERS[1:3], V4=1:12)   Untuk tukarkan V1 dari nilai c(1,2) ke nilai c(0,1) atau tukar huruf, caranya:\n1 2  DT[.(V1 = 1:2, to = 0:1), on = \"V1\", V1 := i.to] DT[.(V2 = LETTERS[1:3], to = c(\"T\", \"K\", \"D\")), on = \"V2\", V2 := i.to]   Di sini .(V1 = 1:2, to = 0:1) ialah sebagai table rujukan. Sekiranya rujukkan (lookup table) tidak tersedia, boleh di buat berasingan:\n1 2 3 4 5 6 7 8 9 10 11 12 13  lut1 \u003c- data.table(V1 = 1:2, to = 0:1) lut2 \u003c- data.table(V2 = LETTERS[1:3], to = c(\"T\", \"K\", \"D\")) lut1 V1 to 1: 1 0 2: 2 1 lut2 V2 to 1: A T 2: B K 3: C D   Kemudian bolehlah di update joins data:\n1 2  DT[lut1, on = \"V1\", V1 := i.to] DT[lut2, on = \"V2\", V2 := i.to]   Cara ini diambil dari stackoverflow.\n","description":"","tags":["R","data.table"],"title":"Pemakaian lookup table","uri":"/posts/look-up-table/"},{"categories":["R"],"content":"Ini ialah beberapa penggunaan asas R yang amat berguna walaupun jarang dipakai. Antaranya:\nPasang pakej Cara biasa untuk pasang pakej ialah menggunakan install.packages(). Tetapi sekiranya ingin memasang banyak pekej secara serentank dan memuatkan di R setelah pakej dipasang, cara begini boleh dipakai:\n1 2 3 4 5 6  list.of.packages \u003c- c(\"leaflet\",\"ggplot2\",\"dplyr\",\"gridExtra\",\"psych\",\"data.table\",\"sf\",\"ggrepel\") new.packages \u003c- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])] if(length(new.packages)) install.packages(new.packages, repos = \"https://cloud.r-project.org/\") sapply(list.of.packages, require, character.only = TRUE)   Untuk pasang satu pakej boleh juga buat sebegini:\n1  if(!require(\"rreg\")) {install.packages(\"rreg\")} else {require(\"rreg\")}   Cara ini akan periksa sekiranya pakej rreg belum dipasang makan akan dipasang, sekiranya sudah ada maka akan diaktifkan.\n","description":"","tags":["basic","package"],"title":"Pasang pakej di R","uri":"/posts/package-r/"},{"categories":["data.table"],"content":"Untuk memadamkan barisan di data.table menggunakan reference seperti penggunaan .SD masih belum dilaksanakan. Cara ini diambil dari perbincangan di GitHub data.table. Fungsi delete dibuat seperti begini:\n1 2 3 4 5 6 7 8 9 10 11  delete \u003c- function(DT, del.idxs) { # pls note 'del.idxs' vs. 'keep.idxs' keep.idxs \u003c- setdiff(DT[, .I], del.idxs); # select row indexes to keep cols = names(DT); DT.subset \u003c- data.table(DT[[1]][keep.idxs]); # this is the subsetted table setnames(DT.subset, cols[1]); for (col in cols[2:length(cols)]) { DT.subset[, (col) := DT[[col]][keep.idxs]]; DT[, (col) := NULL]; # delete } return(DT.subset); }   Cara pemakaiannya ialah seperti dibawah. Barisan yang dibuang di DT memerlukan indeks barisan. Untuk dapatkan indeks untuk barisan yang ingin dipadakan boleh dibaca di baway tajuk duplikasi.\n1  DT \u003c- delete(DT, del.idxs)   ","description":"","tags":["data.table","row","R"],"title":"Padamkan barisan (row)","uri":"/posts/row-delete/"},{"categories":["aturcara"],"content":"Cara ini diambil dari GitHub robinmoisson. Boleh baca disitu untuk cara selanjutnya. Antaranya:\nPemasangan NVM (Node Version Manager) diperlukan untuk memudahkan pemasangan Node.js dan program staticrypt. Curl diperlukan untuk dapatkan Node.js.\nUntuk memasang hanya NVM, boleh dibuat seperti dibawah atau dibaca di sini:\n1 2  sudo apt-get install curl curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash   Kemudian harus reload environment sebelum memakai komando nvm:\n1  source ~/.profile   Kemudian boleh memasang versi Node. yang diingini, samapada versi LTS atau versi terbaru. Untuk memeriksa versi yang ada guna fungsi ls-remote :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  nvm ls-remote ... ... v10.15.2 (LTS: Dubnium) v10.15.3 (LTS: Dubnium) v10.16.0 (LTS: Dubnium) v10.16.1 (LTS: Dubnium) v10.16.2 (Latest LTS: Dubnium) ... ... v12.5.0 v12.6.0 v12.7.0 v12.8.0   Kemudian bolehlah memasang node.js yang diinginkan. Contohnya versi LTS terakhir:\n1  nvm install v10.16.2   Untuk memasang Node.js terus melalui PPA tanpa memansang NVM, boleh buat begini:\n1 2  sudo apt-get install curl curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -   Kemudian staticrypt boleh dipasang dengan sudo :\n1  npm install -g staticrypt   Satu fail Bila ingin encryp hanya satu fail HTML boleh larikan:\n1  staticrypt contoh.html mypassword   Komando ini akan menghasilkan fail HTML contoh_encrypted.html. Untuk option lainnya boleh dibaca di rujukan. Contohnya untuk bagi nama baru:\n1  staticrypt myfile.html mypassword -o \"myfile_safe.html\" -t \"Tanya siapa?\" -i \"One click only\"   Akan menghasilkan file baru yang bernama myfile_safe.html dan bila dibuka untuk login akan bertanjuk Tanya siapa? dan di bawah tajuk tersebu tertulis One click only.\nSatu folder Untuk encrypt semua HTML fail di satu folder boleh buat begini:\n1  find . -type f -name \"*.html\" -exec staticrypt {} mypassword \\;   Semua fail-fail HTML di folder dimana komando dilarikan akan menjadi namafile_encrypted.html.\n","description":"","tags":["html","aturcara","encrypt"],"title":"Static encrypting HTML","uri":"/posts/static-encrypt/"},{"categories":["data.table"],"content":"Secara umumnya penggunaan loop tidak disarankan di R kerana ianya akan mengunakan banyak memory dan memakan masa yang lambat. Akan tetapi data.table menperkenalkan fungsi set untuk mempercepatkan proses. Asasnya ialah sebegini:\nset(dt, i, j, value)  Contoh pemakainnya bila ingin menukarkan NA ke angka yang diinginkan sepert 99.\n1 2 3  for (j in seq_len(ncol(DT))){ set(DT, which(is.na(DT[[j]])), j = j, value = 99) }   Contoh lain bila ingin membersihkan whitespace disemua kolom di data.table boleh dibuat seperti begini. class dipastikan sebagai character dahulu, kerana sekiranya integer atau nummeric maka ia tidak valid.\n1 2 3 4  for (j in seq_len(ncol(DT))){ if(class(DT[[j]]) == 'character') set(DT, j = j, value = trimws(DT[[j]])) }   ","description":"","tags":["loop","data.table","R"],"title":"Loop atau set di data.table","uri":"/posts/loop-set/"},{"categories":["plot"],"content":"geom_line() sering digunakan untuk menunjukkan trend. Pengguaannya mudah tetapi untuk memastikan yang garisan akan bersambung, variabel di x haruslah jenis continuous. Fungsi ini boleh juga dipakai untuk data jenis category akan tetapi pendekatannya agak berlainan. Pembakaian cara biasa menyebabkan garisan tidak bersambung.\nKategori Cara ini ialah dengan memakai aes(group=1) untuk memastikan yang ggplot() tahu bahawa data point di x adalah dikumpulan yang sama dan garisan harus disambungkan. Contohnya:\n1  ggplot(data, aes(x = kategoriVar, y = peratus, group = 1)) + geom_line()   NA Antara sebab lain yang menjadikan geom_line() tidak bersambung ialah apabilah terdatap nilai NA atau missing data. Nilai ini harus dikeluarkan dari data agar barisan akan barsambung. Contohnya yang diambil dari StackOverflow.\n1 2 3 4  ggplot(df) + geom_point(aes(x=time, y=observation), color=\"grey\")+ geom_line(data=df[!is.na(df$prediction),],aes(x=time, y=prediction), color=\"black\")+ geom_point(aes(x=time, y=prediction), color=\"blue\")   Untuk melihat bagaimana plot dengan nilai NA. Diambil dari gist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  library(ggplot2) set.seed(234) # Make some fake data mydata \u003c- data.frame(x = 2000:2010, y = rnorm(11, 5, 2)) # First plot, all lines are connected correctly ggplot(mydata, aes(x, y)) + geom_line() # Now let's make some of the values NA mydata[sample(1:nrow(mydata), 2, replace = FALSE),\"y\"] \u003c- NA # Now plot the result with the new NAs introduced ggplot(mydata, aes(x, y)) + geom_line() # We should see a plot with disconnected lines   ","description":"","tags":["plot","ggplot","geom_line"],"title":"Tips untuk guna geom_line","uri":"/posts/geom-line/"},{"categories":["nasihat"],"content":"Bila menjalankan pembersihan dan penyusunan data adalah disarankan untuk membuat nota-nota mengenai langkah-langkah yang diambil dalam menyelesaikan kerja. Ini adalah sebagai nasihat berkenaan dengan aliran kerja yang boleh dibuat supaya rujukan akan lebih jelas dan senang untuk dipakai beberapa kali.\nBahagikan kerja-kerja menyusun dan membersikan data kepada bahagian seperti berikut:\n Data asal (raw data) Pemeriksaan (validation) Pembetulan tambahan (additional info.)  Data asal Bahagian ini ialah berkaitan dengan kerja-kerja secara langusung dari data asal. Dimana data tersebut diambil dan sekiranya terdapat kerja-kerja menggabungkan dengan data-data lain. Selain itu pembersihan teknikal seperti kode yang salah.\nPemeriksaan Ini adalah kumpulan kerja-kerja berkaitan dengan pemeriksaan data. Contohnya umur yang melebihi 150 tahun atau ketinggian 3 meter. Adakah informasi tersebut betul atau kesalahan semasa pendaftaran data.\nPembetulan tambahan Data juga boleh bertukar disebabkan informasi tambahan yang diberikan selepas kerja-kerja pembersihan dari data asal dan pemeriksaan data yang tidak logik dibuat. Kebanyakkan pembetulan yang dibuat di sini dijalankan secara manual dan berasaskan kepada informasi tambahan yang tidak terdapat di data asal.\n","description":"","tags":["nasihat","R"],"title":"Aliran kerja buat kod R","uri":"/posts/aliran-kerja/"},{"categories":["R"],"content":"Untuk menukarkan kode penggunaan ifelse adalah cara yang senang dipakai. Akan tetapi penggunaannya di base R memakai masa yang panjang terutama sekirannya melarikan di data yang besar. Ini kerana penggunaan ifelse di base terlebih dahulu menyusun data sebelum membuat pilihan.\nCara yang diterangkan disini ialah untuk pemakaian ifelse di data.table dan cara-cara lain yang diperkenalkan di pakej dplyr atau pakej yang lainnya.\nCara data.table Cara yang biasa di data.table ialah menggunakan teknik DT[i,j,by]. Contoh lain bila ingin menukarkan var2 kepada angka 2 sekiranya var1 ialah ja.\n1  DT[var1 == \"ja\", var2 := 2]   Contoh di bawah menggunakan cara piping dengan magrittr.\n1 2 3  ispDT[, ispad2 := 0] %\u003e% .[alder \u003e= 10 \u0026 diagVar \u003e= 2, ispad2 := 1] %\u003e% .[alder \u003c 10 \u0026 diagVar \u003e= 5, ispad2 := 1]   Sekiranya ingin menukarkan pelbagai nilai di var1 contohnya ja = 1 dan nei = 2 di var2 boleh juga dibuat seperti cara begini menggunakan prinsip di SQL:\n1  DT[.(var1 = c(\"ja\", \"nei\"), to = 1:2), on = \"var1\", var2 := i.to]   Pengunaan set juga disarankan untuk mempercepatkan proses di data.table sekiranya ingin memakai loop. Contoh bila ingin menukarkan semua kolom yang menggandungi angka 3 atau 5 kepada nilai NA boleh dibuat seperti begini:\n1 2 3  for(j in seq_along(DT)) { set(DT, i=which(DT[[j]] %in% c(3,5)), j=j, value=NA) }   Cara yang lebih advance boleh dibaca di Stack Overflow. Ringkasan penerangan cara ini:\nWe specify the ‘selectedcols’ in .SDcols, grouped by sequence of rows, we unlist the Subset of Data.table (unlist(.SD)), get the index of the first non-NA value (‘j1’), use that to get the ‘v1’ corresponding to the index and the column names, assign (:=) to create two new columns.\nAim is to get the best value for each row which is the value of the first non-NA column in the given order of selected columns.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  library(data.table) library(magrittr) n \u003c- 7 set.seed(1234) dt \u003c- sample.int(100, n*5, replace = TRUE) %\u003e% ifelse(. \u003c 35, NA, .) %\u003e% matrix(, nrow = n) %\u003e% as.data.table() selected_cols \u003c- c(\"V3\", \"V4\", \"V1\") dt[, c(\"best_val\", \"best_col\") := {v1 \u003c- unlist(.SD) j1 \u003c- which(!is.na(v1))[1] list(v1[j1], names(.SD)[j1]) }, .SDcols = selected_cols, by = 1:nrow(dt)] dt # V1 V2 V3 V4 V5 best_val best_col #1: NA NA NA NA 84 NA NA #2: 63 67 84 NA NA 84 V3 #3: 61 52 NA NA 46 61 V1 #4: 63 70 NA NA NA 63 V1 #5: 87 55 NA 82 NA 82 V4 #6: 65 NA NA 53 51 53 V4 #7: NA 93 NA 92 NA 92 V4   Cara dplyr Menggunakan fungsi ifelse dimana ianya lebih cepat dari base R ifelse. Penerangan lanjut boleh dibaca di blog Holly Emblem.\n1 2 3  ispDT[, ispad1 := 0] ispDT[, ispad1 := dplyr::if_else(alder \u003e=10 \u0026 diagVar \u003e=2, 1, 0)] ispDT[, ispad1 := dplyr::if_else(alder \u003c 10 \u0026 diagVar \u003e=5, 1, ispad1)]   ","description":"","tags":["ifelse","R","data.table"],"title":"Pengunaan ifelse","uri":"/posts/ifelse/"},{"categories":["R"],"content":"Untuk menggunakan pelbagai objekt tanpa mengulangi komando beberapa kali boleh dilakukan semada menggunakan loop atau salah satu cara apply. Masalahnya bila objekt-objekt disenaraikan sebagai vektor, objekt tersebut ditukarkan ke struktur chr. Oleh sebab itu objekt tersebut tidak dapat diproses seterusnya.\nSalah satu penyelesaian masalah ini ialah menggunakan sapply. Akan tetapi ianya bergantung dengan penggunaan argument:\n- `USE.NAME = TRUE`. - `get()`  Contohnya, bila ingin menggunakan objekt2 ini di .GlobalEnv:\ndt2000 dt2001 dt2002 dt2013 dt2014  Untuk dapatkan semua objekt-objekt diatas, boleh dikumpulkan menggunakan vector seperti begini:\n1 2 3 4  objAll \u003c- grep(\"^(dt200|dt201)*$\", ls(), ignore.case = TRUE, value = TRUE) objAll [1] \"dt2000\" \"dt2001\" \"dt2002\" \"dt2013\" \"dt2014\"   Untuk mencapai objekt2 itu melalui objAll, boleh menggunakan sapply.\n1  sapply(objAll, function(x) setDT(get(x)), USE.NAMES = TRUE)   Atau untuk menggunakan fungsi lain:\n1 2 3 4  ## Convert til excel indK \u003c- grep(\"^dt200\", ls(), value = TRUE) pathXL \u003c- \"~/Git-work/bdr/rapport/portal/excel/\" sapply(indK, function(x) write.xlsx(get(x), paste0(pathXL, x, \".xlsx\")), USE.NAMES = TRUE)   Komando diatas menukarkan semua object di objAll ke data.table. Tanpa memakai USE.NAMES komando ini tidak akan berhasil kerana vector di objAll dibaca sebagai character. Selain itu penggunaan get juga penting untuk memastikan yang kandungan di objAll mempunyai nilai.\nContoh komando untuk dapatkan semua nama kolom sykehus di semua data.table. Penggunaan \\\\b diawal dan akhir perkataan ialah untuk menetapkan nama kolom betul-betul hanya sykehus tanpa tambahan contohnya inn_sykehus atau sykehus_2\n1  sapply(objAll, function(x), grep(\"\\\\bsykehus\\\\b\", names(get(x)), ignore.case = TRUE, value = TRUE), USE.NAMES = TRUE)   ","description":"","tags":["R","object"],"title":"Dapatkan objekt sebagai vektor","uri":"/posts/vector-object/"},{"categories":["credits"],"content":"I shifted from Jekyll to Hugo. But this transition won’t have been easy without the available theme and contribution of people who shared their knowledge on the web. Credits to the reference and theme used for this site.\nThe theme used for this site is hugo-lithium-theme. I also add some function for back-to-top from vfeskov.\n","description":"","tags":["lithium","js"],"title":"Credits","uri":"/posts/credit-site/"},{"categories":["R"],"content":"Untuk membuat peta menggunakan R boleh memakai pelbagai jenis pakej. Cara yang senang ialah samada cara sp atau sf. Penerangan di sini menggunakan cara sf. Untuk mengikuti cara ini, pakej-pekej di bawah perlu dipasangkan terlebih dahulu.\n1 2 3 4 5 6 7 8  list.of.packages \u003c- c(\"ggplot2\",\"dplyr\",\"sf\",\"ggrepel\") new.packages \u003c- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])] if(length(new.packages)) install.packages(new.packages) sapply(list.of.packages, require, character.only = TRUE) kart_sf = sf::st_read(\"~/Git-personal/Rujukan-R/norge/NOR_adm1.shp\", stringsAsFactors = FALSE) class(kart_sf)   Sekiranya ada masalah memasang pekej sf di Ubuntu disebabkan masalah di gdal-config, pasangkan libgdal-dev diterminal.\n1  sudo apt install libgdal-dev   kemudian bolehlah pasangkan pakej sf dengan install.packages('sf').\nSekiranya masalah disebabkan oleh libudunits2-0 dan libudunits2-dev, pasangkan libudunits2-0 dan libudunits2-dev di terminal.\n1  sudo apt install -y libudunits2-0 libudunits2-dev   ","description":"","tags":["R peta"],"title":"Buat peta cara sf","uri":"/posts/peta-sf/"},{"categories":["anroid"],"content":"Peringatan  Termux pasang git Nvim-Rq F2 volume-up+2 Buat init.vim Pasang R cara senang  ","description":"","tags":["termux","R","anroid"],"title":"Pasang R di HP","uri":"/posts/nvim-termux/"},{"categories":["data mining"],"content":"Cari mendapatkan unik data atau penduaan menggunakan data.table. Caranya hampir sama dengan cara di base. Disini akan diterangkan cara pemakaian fungsi unique dan duplicated.\nUnik Untuk mendapatkan barisan yang unik di dataset atau unik di kolom tertentu sahaja boleh menggunakan fungsi unique atau !duplicated. Tunjukajar ini akan menggunakan data contoh di bawah:\nlibrary(data.table) dat \u003c- data.table(a = c(12, 15,16, rep(11:12, 2),15, rep(12,3), 17, 17, 18), b = c(\"h\",NA,letters[1:8],\"e\", \"s\", rep(\"q\",2))) \u003e dat a b 1: 12 h 2: 15 \u003cNA\u003e 3: 16 a 4: 11 b 5: 12 c 6: 11 d 7: 12 e 8: 15 f 9: 12 g 10: 12 h 11: 12 e 12: 17 s 13: 17 q 14: 18 q  Barisan ke 10 12 h dan 11 12 e berpendua.\nFungsi unique di data.table akan memilih barisan-barisan yang unik sahaja. Sekiranya ingin menyusun mengikut abjad atau nombor, boleh tetapkan setkey(). Fungi uniqueN() memberikan jumlah barisan yang unik.\n\u003e setkey(dat, a) \u003e unique(dat) a b 1: 11 b 2: 11 d 3: 12 h 4: 12 c 5: 12 e 6: 12 g 7: 15 \u003cNA\u003e 8: 15 f 9: 16 a 10: 17 s 11: 17 q 12: 18 q \u003e uniqueN(dat) [1] 12  Data hanya tinggal 12 barisan sahaja sebab 12 h di barisan 10 dan 12 e di barisan 11 berpendua dan penduaanya dikeluarkan. Hanya barisan 3 dan 5 sahaja yang disimpan.\nUntuk memilih barisan berdasarkan nilai unik di kolom tertentu, boleh menggunakan fungsi !duplicated. Penggunaan unique akan hanya memberikan nilai-nilai unik sebagai vektor. Akan tetapi penggunaan unique cara data.table memberikan nilai yang tidak diingini kerana unique tidak dipakai bila menggunakan pendekatan awam data.table iaitu DT[i,j,by]. Ia hanya dipakai menggunakan expression cara unique().\n\u003e unique(dat$a) [1] 11 12 15 16 17 18 \u003e dat[!duplicated(a)] a b 1: 11 b 2: 12 h 3: 15 \u003cNA\u003e 4: 16 a 5: 17 s 6: 18 q \u003e dat[unique(a)] a b 1: 16 a 2: 17 s 3: NA \u003cNA\u003e 4: NA \u003cNA\u003e 5: NA \u003cNA\u003e 6: NA \u003cNA\u003e  Duplikasi Untuk mencari duplikasi boleh menggunakan fungsi duplicated atau unique yang terdapat di base. Kedua-duanya akan memberikan vektor. Fungsi duplicated akan memberikan TRUE FALSE manakala unique memberikan data pendua.\nData.table juga menggunakan duplicated atau unique untuk mendapatkan duplikasi. Untuk mengenalpasti semua data yang ada penduanya bolehlah membuat kolom baru yang menetapkan barisan yang berpendua:\n\u003e dat[, fD := .N \u003e 1, by = dat] \u003e dat a b fD 1: 12 h TRUE 2: 15 \u003cNA\u003e FALSE 3: 16 a FALSE 4: 11 b FALSE 5: 12 c FALSE 6: 11 d FALSE 7: 12 e TRUE 8: 15 f FALSE 9: 12 g FALSE 10: 12 h TRUE 11: 12 e TRUE 12: 17 s FALSE 13: 17 q FALSE 14: 18 q FALSE  Untuk melihat kolom tertentu yang berpendua boleh dibuat seperti cara dibawah dimana kolom a dipilih dan semua yang berpendua di kolom tersebut dibariskan:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  dat[duplicated(a)|duplicated(a, fromLast = TRUE), list(dd=sort(a))] dd 1: 11 2: 11 3: 12 4: 12 5: 12 6: 12 7: 12 8: 12 9: 15 10: 15 11: 17 12: 17   Penggunaan fromLast=TRUE ialah untuk mendapatkan barisan terakhir yang berpendua. Sekiranya hanya memakai fromLast=TRUE barisan berpendua yang pertama tidak dikira.\nKekunci Sekiranya ingin membuang semua yang berpendua berasaskan kekunci boleh dibuat seperti contoh dibawah. Contoh ini diambil dari StackOverflow. Cara ini hanya akan berfungsi selepas menetapkan kekunci di data.table dengan setkey atau setkeyv.\n1 2 3 4 5 6 7 8 9 10 11 12  library(data.table) myDT \u003c- fread( \"id,fB,fC 1, b1,c1 2, b2,c2 3, b1,c1 4, b3,c3 5, b1,c1 \") ## Tetapkan kekunci setkeyv(myDT, c('fB', 'fC'))   Untuk dapatkan barisan berpendua berasaskan kekunci fB dan fC.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  dups = duplicated(myDT, by = key(myDT)); myDT[, fD := dups | c(tail(dups, -1), FALSE)] #shift dups to 1 position ie. -1 ## Cara lama dan agak lambat myDT[, fD := .N \u003e 1, by=key(myDT)] ## hasilnya myDT id fB fC fD 1: 1 b1 c1 TRUE 2: 3 b1 c1 TRUE 3: 5 b1 c1 TRUE 4: 2 b2 c2 FALSE 5: 4 b3 c3 FALSE   Indeks barisan Kadang-kadang kita hanya ingin dapatkan indeks barisan yang berpendua tanpa perlu mendapatkan data. Cara ini memerlukan fungi which. Contohnya:\n1 2  \u003e which(duplicated(dat)) [1] 10 11   Untuk menggunakan pendekatan cara data.table adalah seperti dibawah. Cara pertama dan kedua hanya memberikan index barisan terakhir atau pertama yang berpendua manakala cara ketiga memberikan semua barisan yang berpendua.\n\u003e dat[duplicated(dat), which=TRUE] [1] 10 11 ## Penggunaan fromLast \u003e dat[duplicated(dat, fromLast=TRUE), which=TRUE] [1] 1 7 ## Atau utk dapatkan semua barisan yang berpendua \u003e dat[duplicated(dat)|duplicated(dat, fromLast=TRUE), which=TRUE] [1] 1 7 10 11  ","description":"","tags":["data.table","R","duplicate","unique"],"title":"Duplikasi data atau unik","uri":"/posts/duplikasi/"},{"categories":["Ubuntu"],"content":"Untuk meng-encrypt guna EncFS dan meletakkan fail-fail di Dropbox boleh dibuat seperti begini:\nPerlu pasang program EncFS\n$ sudo apt-get install encfs  Kemudian gunakan program EncFS dengan menetapkan folder yang akan di encrypt. Caranya:\n$ encfs ~/Dropbox/.encrypted ~/Private  Ini akan membuat dua directori, dimana folder di Dropbox ialah tempat fail-fail encrypted disimpan. Folder Private ialah untuk menyapai fail-fail yang di decrypted. EncFS akan meminta untuk membuat kata kekunci dan bila diminta untuk tetapkan jenis kekunci, pilih “p” untuk paranoia mode sudah memadai.\nUntuk peringatan:\n Jangan letakkan sebarang fail di folder yang simpan di Dropbox. Fail-fail hanya disimpan di folder Private yang kemudiannya di kemaskinikan secara automatik ke folder di Dropbox untuk di encrypt. Jangan buang fail .encfs.xml  Untuk unmount folder yang di-encrypt, larikan:\n$ fusermount -u ~/Private  Untuk dapatkan fail-fail yang di encrypt, larikan:\n$ encfs ~/Dropbox/.encrypted ~/Private  ","description":"","tags":["Linux","Ubuntu","Encrypting"],"title":"Encrypting guna EncFS","uri":"/posts/encrypting-file/"},{"categories":["R"],"content":"Terdapat pelbagai cara untuk larikan Shiny App. Sebagai rujukan boleh dibaca di laman Shiny. Penggunaan fungsi runApp() dan shinyAppDir() akan diterangkan disini.\nMenggunakan runApp() Satu fail app.R Untuk menggunakan fungsi runApp(), cara yang senang digunakan ialah dengan menyediakan fail app.R. Fail ini harus mengandungi ui dan server. Contohnya:\n1 2 3 4 5  library(shiny) ui \u003c- fluidPage() server \u003c- function(input, output) {} shinyApp(ui = ui, server = server)   Sekiranya menggunakan program RStudio maka butang Run App akan keluar dan boleh digunakan untuk melarikan app. Sekiranya mengunakan program lain contohnya Emacs ESS maka boleh larikan dengan cara :\n1 2  library(shiny) runApp(\"app.R\")   Pelbagai fail di folder Sekiranya app mengandungi kod yang panjang dimana ui dan server di letakkan di fail-fail berasingan, fail-fail ini harus diletakkan di folder sendiri bersama dengan fail-fail lain contohnya global.R, data.R atau module.R termasuk folder www. Fungsi shinyApp() tidak diperlukan untuk melarikan app ini. Penggunaan runApp() boleh digunakan dengan menetapkan nama folder dimana fail-fail tersebut diletakkan. Contohnya isi kandungan di folder myApp\n/home/Git/myApp/ ├── data.R ├── global.R ├── server.R ├── ui.R └── www └── custom.css  Folder www digunakan untuk menyimpan elemen-element lain seperti gambar, javaScript, CSS dan lain-lainnya. Untuk melayarkan app boleh dilakukan pelbagai cara. Antaranya:\n1 2  library(shiny) runApp(\"myApp\")   Sekiranya Shinyapps dibuat sebagai object.\napp \u003c- shinyApp(ui = ui, server = server) runApp(app)  Atau hanya terus melarikan app di console tanpa mengunakan runApp\napp \u003c- shinyApp(ui = ui, server = server) app  Menggunakan shinyAppDir() Melarikan app dengan menetapkan folder sekiranya folder tidak terletak di folder yang sedang digunakan.\nTips lain Sekiranya ingin dapatkan clientData boleh menggunakan session. Contohnya:\n1 2 3 4 5  function(input, output, session) { output$txt \u003c- renderPrint({ session$clientData }) }   ","description":"","tags":["shiny"],"title":"Cara deloy Shiny","uri":"/posts/basic-shiny/"},{"categories":["data.table"],"content":"Untuk menambah kolom baru di data.table boleh menggunakan :=. Sekiranya ingin membuat kolom baru secara loop di pelbagai data.table, cara begini boleh dibuat. Cara-cara ini diambil dari StackOverflow.\nList Cara pertama boleh dibuat dengan mebuat list untuk semua data.table dimana kolom baru ingin ditambah.\n1 2 3 4 5 6 7 8 9 10  library(data.table) my_dts \u003c- list ( centro = data.table(x=letters[1:5], y = 1:5), sur = data.table(x=letters[2:7], y = 3:8), norte = data.table(x=letters[2:10], y = 3:11) ) st \u003c- c(\"centro\", \"sur\", \"norte\") for (i in st) my_dts[[i]][, store := i]   Sekiranya rawdata belum disatukan, boleh dilaksanakan seperti begini. Cara ini membaca semua data sebagai csv dan disatukan sebagai list.\n1 2 3 4 5 6 7 8 9 10 11 12 13  st \u003c- c(\"centro\", \"sur\", \"norte\") all_stores \u003c- do.call( what = rbind, args = lapply( X = st, FUN = function(storeNM){ temp \u003c- fread(input = paste0(storeNM, '.csv')) temp[, store := storeNM] return(temp) } ) )   Vector Semua data.table yang disatukan ke vektor. Cara ini menggunakan fungsi assign dan get.\n1 2 3  for (i in st){ assign(i, get(i)[, store := i]) }   ","description":"","tags":["R","data.table"],"title":"Tambah kolom pelbagai data.table","uri":"/posts/tambah-kolom/"},{"categories":["R"],"content":"Pakej grid dipakai untuk membuat grafik secara asas membolehkan pemakaian aturcara dan peraturan yang lebih anjal mengikut kemahuan sendiri. Ia juga boleh dipakai untuk mengatur kedudukan grafik. Fungsi penting yang dipakai ialah:\n viewport pushViewport grid.draw  viewport dipakai untuk menetapkan kawasan grafik. Fungsi viewport() digunakan untuk tujuan ini. Contohnya:\n1 2 3 4 5 6 7  library(grid) vp1 \u003c- viewport(x = 0.5, y = 0.5, width = 0.2, height = 0.4, just = c(\"left\", \"bottom\"), name = \"vp1\") grid.show.viewport(vp1)     Figure 1: Grid view\n  Operasi ini bermaksud viewport diletakkan di tengah-tengah mukasurat melalui koordinasi x = 0.5 dan y = 0.5. Unit yang dipakai ialah npc atau “Normalised Parent Coordinates” yang menggunakan lokasi kiri bawah (0,0) dan kanan atas (1,1). Lebar dan tinggi juga ditetapkan dengan unit yang sama. Sekiranya ingin menukar unit boleh menggunakan cara unit(2, \"cm\"). Penggunaan just untuk menetapkan dimana koordinasi viewport sebelum meletakkan grob. Contoh di atas meletakkan titik koordinasi x dan y di bawah kiri c(\"left\", \"bottom\") grob.\n","description":"","tags":["R","grid","plot"],"title":"Pemakaian pekej Grid","uri":"/posts/grid/"},{"categories":["ggplot2"],"content":"Ini ialah aturaca membuat plot dan memasukkan table untuk informasi berkaitan plot menggunakan pakej ggplot2. Table untuk informasi juga akan dibuat menggunakan ggplot2 yang kemudiannya digabungkan menggunakan pakej gridExtra.\nUntuk memastikan plot dan table akan sejajar, adalah penting untuk menggunakan skala yang sama. Skala ini boleh menggunakan nombor atau kumpulan (category). Bila menggunakan skala secara category adalah penting untuk menukarkan status kolom ke factor.\nContoh data:\n1 2 3 4 5 6  library(data.table) library(ggplot2) navn \u003c- c(\"Nama1\", \"Nama2 yang panjang\", \"Nama3\") N \u003c- c(112, 210, 150) N2 \u003c- c(200, 250, 170) dat \u003c- data.table(navn, N, N2)   Untuk memastikan kedua-dua plot akan menggunakan skala yang sama, kita boleh buat dummy untuk rujukkan skala. Disini rujukkan skala bermula dari nombor 1 ke nombor 3.\n1 2 3  ## create dummy reference xrow \u003c- nrow(dat) dat[, ref := seq.int(xrow)]   Untuk membolehkan kita menambah perkataan contohnya Lokasi atau Negara, kita perlu tambah skala rujukkan. Bila guna fill=TRUE di fungsi rbindlist maka NA akan dimasukkan di kolom yang kosong.\n1 2 3  ## create ref til extra text eg. N or Total xref \u003c- data.table(ref = xrow + 1) #locate at the end of the rows dt \u003c- rbindlist(list(dat, xref), fill = TRUE) #bind to the end rows   Untuk mengelakkan NA akan dimasukkan diplot, maka kita perlu kosongkan NA. Kemudian kolom yang akan dipakai untuk menamakan plot dan rujukkan plot ditukarkan ke factor.\n1 2 3 4 5  ## navn with NA blir tom dt[is.na(navn), navn := \"\"] ## konvertere dt$navn og dt$ref as facor dt[, `:=`(navn = as.factor(navn), ref = as.factor(ref))]   Setelah menukarkan kolom ke factor bolehlah mendapatkan kandungan kolom tersebut yang dipakai untuk menamakan plot dengan cara membuat vector menggunakan fungsi levels. Untuk tidak memasukkan NA diskala, hanya nama yang ada di vector sahaja yang dipakai.\n1 2 3  ## get levels for navn etter at den er konvertert til factor pnavn \u003c- levels(dt$navn) dummyref \u003c- factor(1:xrow) #brukes til scale_x_discrete for å legge labels til aksen eksludert dummy linje 4 som skal brukes senere til N   Selepas itu bolehlah buat plot menggunakan rujukkan dummy dan memastikan yang ref dipakai secara factor.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  ## plot etter at \"ref\" og \"navn\" er konvertert til factor (plotMain \u003c- ggplot(dt, aes(factor(ref), N)) + geom_bar(stat = \"identity\") + coord_flip() + scale_x_discrete(breaks = factor(dt$ref), labels = dt$navn) + theme( #theme react on the current plot for x and y axis not before it's flip #after flip then navn is current y-axis axis.text.y = element_text(color = \"blue\", size = 10, hjust = 1), axis.title.y = element_blank(), axis.line.y = element_blank(), #ta bort linje på y-axis axis.ticks.y = element_blank(), axis.line.x = element_line(color = \"black\"), panel.background = element_blank() )) ## plot tom ramme til tekst (rpp \u003c- ggplot(dt, aes(factor(ref))) + scale_y_continuous(limits = c(0, 1)) + coord_flip() + theme( axis.line = element_blank(), axis.text = element_blank(), axis.title = element_blank(), axis.ticks = element_blank(), panel.background = element_blank() )) ## plot text figure (plotText \u003c- rpp + annotate(\"text\", x = factor(4), y = 0.25, label = \"Local\") + annotate(\"text\", x = factor(4), y = 0.75, label = \"Nation\") + annotate(\"text\", x = factor(dt$ref), y = 0.25, label = dt$N, hjust = 1) + annotate(\"text\", x = factor(dt$ref), y = 0.75, label = dt$N2, hjust = 1) + geom_vline(xintercept = c(3.8, 4.2)) )   Untuk meletakkan plot dan table bersama boleh guna grid.arrange dari pakej gridExtra. Tetapi cara ini tidak memastikan yang y-aksis seragam.\n1 2 3 4 5  library(gridExtra) (plotpp \u003c- grid.arrange(ggplotGrob(plotMain), ggplotGrob(plotText), ncol = 2, widths = unit(c(0.8, 0.2), \"npc\")) )   Untuk meletakkan kedua-dua plot dan table bersama dan memastikan yang y-aksis seragam boleh menggunakan cara seperti di bawah. Guna heights utk menyeragamkan aksis y manakala weights untuk menyeragamkan aksis x. Contohnya unit.pmax(pp1$weights)\n1 2 3 4 5 6 7 8 9 10 11  pp1 \u003c- ggplotGrob(plotMain) pp2 \u003c- ggplotGrob(plotText) maxHeight = unit.pmax(pp1$heights, pp2$heights) pp1$heights \u003c- maxHeight pp2$heights \u003c- maxHeight grid.arrange(pp1, pp2, ncol = 2, widths = unit(c(0.8, 0.2), \"npc\")) ggplot2::ggsave(\"plottable1.svg\")   Selain cara ini, boleh juga menggunakan fungsi plot_grid dari pakej Cowplot dan menggunakan align = \"h\" untuk horizontal (sama y-aksis)\n1 2 3 4 5 6  library(cowplot) cplot \u003c- plot_grid(plotMain, plotText, nrow = 1, align = \"h\", rel_widths = c(4, 1)) cowplot::save_plot(\"cowplot.svg\", cplot, ncol = 2, base_aspect_ratio = 1.3) cowplot::ggsave(\"cowplot2.svg\", cplot)   Hasilnya ialah seperti ini:\n","description":"","tags":["ggplot2","table"],"title":"Plot dan table","uri":"/posts/plot-table/"},{"categories":["plot"],"content":"Tunjuk ajar ini ialah berasaskan penggunaan pekej ggplot2. Untuk membuat plot perbandingan dan memasukkan legend untuk perbandingan boleh dibuat seperti berikut.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  library(\"data.table\") data \u003c- fread(\"https://raw.githubusercontent.com/ybkamaleri/dataset/master/gdata.csv\") ## lage tabellen alder group ageWyoming \u003c- data[location == \"Wyoming\", list(n = .N), by = .(agegp)] dataW \u003c- ageWyoming[, { N = sum(n) pros = round(n / N * 100, digits = 1) list(agegp = agegp, n = n, N = N, pros = pros)}] dataW[, location := \"Wyoming\"] ageRest \u003c- data[location != \"Wyoming\", list(n = .N), by = .(agegp)] dataR \u003c- ageRest[, { N = sum(n) pros = round(n / N * 100, digits = 1) list(agegp = agegp, n = n, N = N, pros = pros)}] dataR[, location := \"National\"]   data telah tersedia, bolehlah menyediakan plot yang diinginkan\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  library(\"ggplot2\") ggplot(NULL, aes(agegp, pros)) + geom_bar(data = dataW, # color = local di aes utk buat lagend mapping = aes(color = \"local\"), stat = \"identity\", fill = \"lightblue\") + # point utk national geom_point(data = dataR, # fill eller color kan brukes som dummy for å produsere legend mapping = aes(fill = \"National\"), # om color brukes som dummy til å lage legend så kan color ikke brukes her # men spesifiseringen av farge gjøes i scale_color_manual(value = \"red\") stat = \"identity\", size = 7, shape = 18, color = \"red\") + #shape 18 diamon og 19 rund # limits definere skale for y-aksen fra 0 til 50 # breaks gir delingen i skalen dvs. hver 10-ene # expand gjør at det ikke er mellomrom mellom figuren og x-aksen scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, 10), expand = c(0, 0)) + # Title, subtitle, x- og y-label labs(title = \"Title something\", subtitle = \"Subtitle for graph is here\", x = \"x-label\", y = \"y-label\") + # snu figuren coord_flip() + # warna utk lagend local scale_color_manual(values = \"lightblue\") + # tema spesifikasjoner theme( legend.position = \"top\", legend.title = element_blank(), legend.text = element_text(size = 10), legend.key = element_rect(color = \"white\"), axis.text.y = element_text(color = \"black\", size = 9), plot.margin = unit(c(0,0.5,0,0), \"cm\"), panel.background = element_blank(), panel.border = element_blank(), panel.grid.major.y = element_blank(), panel.grid.major.x = element_line(colour = \"grey\", size = 0.4, linetype = 2), ## panel.grid.minor.x = element_line(colour = \"grey\", size = 0.2, linetype = 2), axis.ticks.y = element_blank(), axis.line.x = element_line(size = 0.5), axis.title.y = element_text(size = 9), axis.title.x = element_text(size = 9))   Hasilnya seperti ini:\n","description":"","tags":["ggplot","geom_point","geom_bar"],"title":"Legend untuk plot perbandingan","uri":"/posts/legend-plot-banding/"},{"categories":["data.table"],"content":"Bagaimana untuk tambah garis baru di data.frame dengan memasukkan jumlah keseluruhan atau Total. Cara yang ditunjukkan di sini ialah dengan menggunakan pakej data.table. Fungsi rbind atau rbindlist boleh digunakan, tetapi cara rbindlist melalui pakej data.table lebih cepat.\n1 2  library(data.table) df \u003c- data.table(v1 = letters[1:10], v2 = 1:10)   Contoh data\nhead(df, n=4) v1 v2 1: a 1 2: b 2 3: c 3 4: d 4  Cara yang paling singkat untuk meletakkan Jumlah di bawah data.frame ialah seperti begini:\n1 2 3 4 5 6 7 8  ## cara rbindlist dfj \u003c- rbindlist(list(df, list(\"Jumlah\", dim(df)[1]))) ## Masukkan jumlah keseluruhan dfjs \u003c- rbindlist(list(df, list(\"Jumlah semua\", sum(df$v2)))) ## cara rbind dfjj \u003c- rbind(df, list(\"Jumlah\", dim(df)[1]))   Hasilnya\nR\u003e dfj v1 v2 1: a 1 2: b 2 3: c 3 4: d 4 5: e 5 6: f 6 7: g 7 8: h 8 9: i 9 10: j 10 11: Jumlah 10  Cara lain ialah dengan membuat data.frame baru dan kombinasikan dengan df\n1 2  dftot \u003c- data.table(v1 = \"Jumlah\", dim(df)[1]) dfcom \u003c- rbindlist(list(df, dftot))   Hasilnya bila Jumlah dimasukkan di bawah data.frame\nR\u003e dfcom v1 v2 1: a 1 2: b 2 3: c 3 4: d 4 5: e 5 6: f 6 7: g 7 8: h 8 9: i 9 10: j 10 11: Jumlah 10  Sekiranya ingin memasukkan informasi dibarisan tertentu boleh buat seperti begini:\n1 2 3 4 5  ## Masukkan selepas barisan ke-3 rbindlist(list(df[1:3, ], as.list(c(\"ZZ\", 6)), df[4:dim(df)[1], ])) ## atau rbindlist(list(df[1:3, ], list(\"ZZ\", 6), df[4:dim(df)[1], ]))   Barisan baru selepas barisan ke 3 dengan \"ZZ\" dan nombor 6 dimasukkan.\n v1 v2 1: a 1 2: b 2 3: c 3 4: ZZ 6 5: d 4 6: e 5 7: f 6 8: g 7 9: h 8 10: i 9 11: j 10  ","description":"","tags":["total","data.table","R"],"title":"Tambah jumlah keseluruhan","uri":"/posts/tambah-jumlah/"},{"categories":["data.table"],"content":"Fungsi yang selalu dipakai bila mengemaskini dan menyusun data ialah penggunaan merge atau join. Cara biasa menggunakan teknik data frame ialah seperti begini:\n1 2 3 4 5 6 7 8 9 10 11 12  library(data.table) DT1 = data.table(area=c('US', 'UK', 'EU', 'Asia'), id=c('c001', 'c002', 'c003', 'c004'), value=c(100, 200, 300, 400) ) DT2 = data.table(ID=c('c001', 'c002', 'c003'), price=c(500, 200, 400), sales=c(20, 30, 15) )   DT1 menggandungi 4 baris dan DT2 hanya 3 baris\nR\u003e DT1 area id value 1: US c001 100 2: UK c002 200 3: EU c003 300 4: Asia c004 400 R\u003e DT2 ID price sales 1: c001 500 20 2: c002 200 30 3: c003 400 15  Guna fungsi ‘merge’ Cara ini menggabungkan data.table menggunakan fungsi merge untuk menggabungkan kedua-dua data yang terdapat dikedua-duanya\n1 2 3 4 5  ## Merge merge(DT1, DT2, by.x = \"id\", by.y = \"ID\") ## Merge data.frame merge.data.frame(DT1, DT2, by.x = \"id\", by.y = \"ID\")    id area value price sales 1 c001 US 100 500 20 2 c002 UK 200 200 30 3 c003 EU 300 400 15  Sekiranya ingin mendapatkan semua data dikedua-dua DT, boleh pakai argument all=TRUE atau hanya salah satu DT dengan all.x=TRUE.\n1  merge(DT1, DT2, by.x = \"id\", by.y = \"ID\", all = TRUE)   Gabungan menggunakan ‘key’ Fungsi merge juga boleh digunakan dengan data.table. Cara lain untuk menggabungkan dua data menggunakan data.table ialah seperti begini:\n1 2 3 4 5 6  setkey(DT1, id) setkey(DT2, ID) ## right outer sum1 \u003c- DT1[DT2] sum2 \u003c- DT2[DT1]   sum1 hanya menyimpan data yang terdapat di D2 iaitu right outer manakala sum2 memasukkan semua ID yang terdapat di DT1 dan memasukkan NA sekiranya tanpa data\n1 2 3 4 5 6 7 8 9 10 11 12  R\u003e sum1 area id value price sales 1: US c001 100 500 20 2: UK c002 200 200 30 3: EU c003 300 400 15 R\u003e sum2 ID price sales area value 1: c001 500 20 US 100 2: c002 200 30 UK 200 3: c003 400 15 EU 300 4: c004 NA NA Asia 400   Untuk hanya menyimpan match yang terdapat dikedua-dua dataset, boleh guna argument nomatch=0.\n1  Resultat \u003c- DT1[DT2, nomatch = 0]   Gabungan tanpa menukarkan data.table sedia ada Cara lain menggunakan data.table sekiranya key tidak ditetapkan. Untuk menyimpan hasilnya harus membuat objek atau data.table baru.\n1 2 3  ## tetapkan key menggunakan 'on DT12 \u003c- DT1[DT2, on = c(id = \"ID\")] DT21 \u003c- DT2[DT1, on = c(ID = \"id\")]   Gabungan ke data.table sedia ada Sekiranya tidak ingan membuat objek baru dan hanya ingin memasukkan kolom ke data.table yang sedia ada, boleh pakai mget sekiranya pelbagai kolom yang ingin dimasukkan dan get untuk hanya satu kolom.\n1 2 3 4 5 6 7 8 9  ## Cara get DT4 \u003c- copy(DT1) var \u003c- \"price\" DT4[DT2, on = c(id = \"ID\"), (var) := get(var)] ## Cara mget DT3 \u003c- copy(DT1) vars \u003c- c(\"price\", \"sales\") #nama kolom di DT2 DT3[DT2, on = c(id = \"ID\"), (vars) := mget(vars)]   Keputusannya dengan memakai mget.\n1 2 3 4 5 6  \u003e DT3 area id value price sales 1: US c001 100 500 20 2: UK c002 200 200 30 3: EU c003 300 400 15 4: Asia c004 400 NA NA   Pelbagai data.table Fungi merge dipakai bila menggabungkan dua data.table sahaja. Untuk menggabungkan pelbagai data.table boleh menggunakan fungsi Reduce. Secara awamnya fungsi Reduce boleh dipakai seperti begini:\n1  Reduce(merge, list(DT1, DT2, DT3, ...))   Tetapi sekiranya nama pada data.table yang ingin digabungkan tidak sama, maka pilihan all=TRUE harus dipakai supaya semua variable dimasukkan tidak kira ianya terdapat hanya di salah satu data.table atau semuanya. Untuk membolehkan all=TRUE option boleh dibuat secara pemakaian function:\n1  Reduce(function(...) merge(..., all = TRUE), list(DT1, DT2, DT3, DT4))   Cara lain boleh juga membuat function diluar Reduce. Seperti begini:\n1 2 3 4 5  mymerge = function(x, y) merge.data.table(x, y, all = TRUE) Reduce(mymerge, list(DT1, DT2, DT3, DT4)) ## bila tidak ada key function(x, y) x[y, on = \"nama_kolom\"]   Nama object di global Sekiranya ingin mendapatkan nama-nama object yang ingin digabungkan di global environment, boleh menggunakan fungsi mget. Contohnya untuk dapatkan semua objek yang diakhiri dengan .pas.\n1 2 3  objBanyak \u003c- mget(ls(pattern = \"\\\\.pas$\")) Reduce(merge, objBanyak)   ","description":"","tags":["join","merge","data.table","get","mget"],"title":"Merge atau join","uri":"/posts/merge-join/"},{"categories":["data.table"],"content":"Ini ialah cara untuk recode atau compute data menggunakan pakej data.table.\nRecode Mendukarkan nilai dikolom tanpa membuat kolom baru boleh dilakukan seperti begini. Contoh dataset yang digunakan untuk proses ini ialah DT.\n1 2  library(data.table) DT \u003c- data.table(a=rep(0:1, 5), b=letters[1:10])   \u003e DT a b 1: 0 a 2: 1 b 3: 0 c 4: 1 d 5: 0 e 6: 1 f 7: 0 g 8: 1 h 9: 0 i 10: 1 j  Bagaimana untuk menukarkan kod di kolom a dari [0,1] ke [3,4]?\nCara dengan menggunakan pakej data.table ialah seperti begini:\n1  DT[.(a = 0:1, to = 3:4), on = \"a\", a := i.to]   Kolom a ditukarkan ke kod [3,4]. Pemakaian a := i.to untuk memastikan kolom a digantikan dengan nilai yang baru tanpa membuat kolom baru yang mengandungi nilai tersebut.\n\u003e DT a b 1: 3 a 2: 4 b 3: 3 c 4: 4 d 5: 3 e 6: 4 f 7: 3 g 8: 4 h 9: 3 i 10: 4 j  Compute Membuat kolom baru berasaskan kondisi dikolom yang sedia ada. Contoh praktikal yang saya gunakan untuk memberikan nama-nama rumah sakit kolom baru iaitu hosKort.\n1 2 3 4 5 6 7 8 9 10  hosNavnKort \u003c- c(\"Akershus\", \"Forde\", \"Haugesund\", \"Haukeland\", \"Sandessjoen\", \"Finnmark\", \"Kristiansund\", \"Molde\", \"Namsos\", \"Bodo\", \"Trondheim\", \"Stavanger\", \"Vestfold\", \"Gjovik\", \"Lillehammer\", \"Elverum\", \"Levanger\", \"Telemark\", \"Ostfold\", \"Arendal\", \"Kristiansand\", \"Ulleval\", \"Nord_norge\", \"Harstad\", \"Drammen\", \"Alesund\") # hosDT[, kortID := hospID] # hosDT[.(kortID = 1:26, to = hosNavnKort), on = \"kortID\", hosKort := i.to] hosDT[.(hospID = 1:26, to = hosNavnKort), on = \"hospID\", hosKort := i.to]   Cara ini sama seperti melarikan cara begini:\n1 2 3  hosDT[hospID == 1, hosKort := \"Akershus\"][ hospID == 2, hosKort := \"Forde\"][ hospID == 3, hosKort := \"Haugesund\"][ dan seterusnya... ]   Sekiranya asas untuk menghasilkan kolom baru bergantung kepada lebih dari satu kolom boleh dibuat seperti begini.\n1  dd1 \u003c- data.table(a=rep(c(\"Ja\", \"Nei\"), 5), b = rep(letters[1:3],2))   Buat kolom c dan nilai 1 sekiranya kolom a ialah Nei.\n1  dd1[list(a = \"Nei\", to = 1), on = \"a\", c := i.to]   Buat kolom d dengan nilai 2 sekiranya kolom a ialah Ja dan kolom b ialah a\n1  dd1[list(a=\"Ja\", b=\"a\", to = 2), on = c(\"a\", \"b\"), d := i.to]   Buat kolom f dengan nilai 5 sekiranya kolom a ialah Ja dan kolom b bernilai b. Sekiranya kolom a bernilai Ja dan kolom b bernilai c maka kolom f diberikan nilai 8.\n1 2 3  a1 \u003c- c(\"b\", \"c\") dd1[.(a=\"Ja\", b = a1, to = c(5,8)), on = c(\"a\", \"b\"), f := i.to]   ","description":"","tags":["recode","compute","R"],"title":"Recode atau compute data","uri":"/posts/recode/"},{"categories":["R"],"content":"Rownames Pernahkah melihat data frame dimana kolom pertama tidak ada nama dan anda tidak tahu bagaimana untuk merujuk kolom tersebut? Sekiranya anda pernah menemui masalah tersebut sila baca penerangan dan penyelesaian di sini.\nSituasi ini adalah disebabkan nama tersebut ialah nama untuk barisan sahaja i.e rownames, seperti nama untuk kolom i.e colnames. Contohnya:\n1 2  DT \u003c- mtcars[1:5, 1:5] DT   Di sini anda lihat kolom pertama tidak mempunyai nama. Untuk mengetahui nama barisan boleh gunakan rownames(DT).\n: mpg cyl disp hp drat : Mazda RX4 21.0 6 160 110 3.90 : Mazda RX4 Wag 21.0 6 160 110 3.90 : Datsun 710 22.8 4 108 93 3.85 : Hornet 4 Drive 21.4 6 258 110 3.08 : Hornet Sportabout 18.7 8 360 175 3.15  Untuk menggunakan kolom pertama dalam kode-kode, kolom pertama harus diberikan nama kolom. Hanya menggunakan DT[1] tidak akan berjaya. Cara untuk menukarkan rownames ke colnames boleh dibuat seperti berikut:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  DT \u003c- mtcars[1:5, 1:5] ## cara 1 DT2 \u003c- cbind(rownames(DT), DT) rownames(DT2) \u003c- NULL names(DT2)[1] \u003c- \"nama\" ## cara 2 DT3 \u003c- DT namesDT \u003c- names(DT3) DT3 \u003c- setNames(cbind(rownames(DT3), DT3, row.names = NULL), c(\"nama\", namesDT)) R\u003e DT3 nama mpg cyl disp hp drat 1 Mazda RX4 21.0 6 160 110 3.90 2 Mazda RX4 Wag 21.0 6 160 110 3.90 3 Datsun 710 22.8 4 108 93 3.85 4 Hornet 4 Drive 21.4 6 258 110 3.08 5 Hornet Sportabout 18.7 8 360 175 3.15   Sekarang kolom pertama mempunyai nama dan boleh dirujuk dalam memanipulasi data. Rownames sekarang digantikan ke nombor 1 ke 5.\nUntuk menggunakan cara data.table adalah seperti begini:\n1 2 3 4 5 6 7  DT4 \u003c- mtcars[1:5, 1:5] nama2 \u003c- rownames(DT4) library(data.table) setDT(DT4) DT4[, nama := nama2] DT4   Kolom nama daripada rownames dimasukkan\n: mpg cyl disp hp drat nama : 1: 21.0 6 160 110 3.90 Mazda RX4 : 2: 21.0 6 160 110 3.90 Mazda RX4 Wag : 3: 22.8 4 108 93 3.85 Datsun 710 : 4: 21.4 6 258 110 3.08 Hornet 4 Drive : 5: 18.7 8 360 175 3.15 Hornet Sportabout  Colnames Kadang-kadang kita ingin menukarkan nama kolom ke nama lain. Untuk menukarkan nama kolom boleh dibuat dengan pelbagai cara. Cara setNames boleh dirujuk seperti di atas. Antara cara-cara lain ialah seperti berikut:\n1 2 3 4 5  DT \u003c- mtcars[1:5, 1:5] nama1 \u003c- c(\"cth1\", \"cth2\") names(DT)[c(3, 5)] \u003c- nama1 DT   Nama untuk kolom 3 dan 5 ditukar\n: mpg cyl cth1 hp cth2 : Mazda RX4 21.0 6 160 110 3.90 : Mazda RX4 Wag 21.0 6 160 110 3.90 : Datsun 710 22.8 4 108 93 3.85 : Hornet 4 Drive 21.4 6 258 110 3.08 : Hornet Sportabout 18.7 8 360 175 3.15  Cara lain ialah menggunakan pakaj data.table.\n1 2 3 4 5 6 7 8  DT \u003c- mtcars[1:5, 1:5] library(data.table) setDT(DT) nama2 \u003c- c(\"kol1\", \"kol2\") setnames(DT, c(\"mpg\", \"hp\"), nama2) DT   Kolom mpg dan hp ditukarkan ke kol1 dan kol2.\n: kol1 cyl disp kol2 drat : 1: 21.0 6 160 110 3.90 : 2: 21.0 6 160 110 3.90 : 3: 22.8 4 108 93 3.85 : 4: 21.4 6 258 110 3.08 : 5: 18.7 8 360 175 3.15  ","description":"","tags":["mining","rownames","colnames"],"title":"Rownames atau colnames","uri":"/posts/col-and-row/"},{"categories":["package"],"content":"Pakej rreg sudah dimuatkan di CRAN pada 8 Ogos 2017. Pakej ini dibuat untuk memudahkan kerja-kerja visualisasi untuk data-data daripada pendaftaran kesihatan di Nasjonalt Servicemiljø for medisinske kvalitetsregistre. Untuk memakai pakej rreg boleh dipasang secara langsung dari CRAN.\n1  install.packages(\"rreg\", dependencies = TRUE)   Pakaj ini menggandungi beberapa fungsi untuk visualisasi data. Fungsi-fungsi berikut ialah:\n Bar chart dengan regbar Radar diagram menggunakan regrad Untuk menunjukkan tren dengan regline Menggunakan “confidence interval” atau “standard error” dengan regerr  Contoh penggunaan boleh dilihat dengan melarikan contoh-contoh yang tersedia dengan menggunakan fungsi example.\n1 2  library(rreg) example(regbar)   ","description":"","tags":["aturcara","plot"],"title":"R pakej rreg","uri":"/posts/pkg-rreg/"},{"categories":["data.table"],"content":"Kekadang nama untuk level yang diberikan di faktor bagi variabel jenis kumpulan (category) tidak bersesuaian dengan yang kita inginkan. Untuk menukarkan nama level tersebut kepada nama-nama yang lain, beberapa cara boleh dipakai. Sesetengah cara yang ditunjukkan di sini bergantung dengan jenis data yang dipakai iaitu data.frame atau data.table.\nData frame Untuk menggunakan cara data.frame ialah seperti di bawah. Sekiranya df$bandar tidak ditukarkan ke factor, nilai levels yang ditetapkan iaitu nama bandar-bandar hanya akan diketahui bila melihat struktur data dengan str (structure) atau attr (attribute).\n1 2 3 4 5 6 7 8 9  var \u003c- LETTERS[1:5] bandar \u003c- c(1:4, 9) #sebagai numeric df \u003c- data.frame(var, bandar) levels(df$bandar) \u003c- c(\"Tawau\", \"Semporna\", \"Kunak\", \"Lahad Datu\", \"lain-lain\") ## untuk lihat attribute variabel bandar yang ditetapkan seperti di atas str(df) attr(df$bandar, \"levels\")   Levels nilai iaitu nama bandar-bandar boleh dilihat dengan menukarkan variable bandar dari jenis nombor (numeric) ke faktor (factor).\n1 2 3 4  ## tukar 'bandar' ke factor df2 \u003c- df df2$bandar \u003c- factor(df2$bandar) levels(df2$bandar) \u003c- c(\"Tawau\", \"Semporna\", \"Kunak\", \"Lahad Datu\", \"lain-lain\")   Sekiranya ingin menetapkan labels (nama bandar-badar di residensi Tawau) bagi levels tertentu contohnya nilai c(1,2,3,4,9), cara ini boleh dipakai:\n1 2  nilai \u003c- c(\"Tawau\", \"Semporna\", \"Kunak\", \"Lahad Datu\", \"lain-lain\") df$bandar \u003c- factor(df$bandar, levels = c(1:4, 9), labels = nilai)   Cara ini untuk mengelakkan kesilapkan menamakan (labels) untuk levels.\nData table Sekiranya ingin memakai cara data.table, data harus dikonvert ke data.table contohnya setDT(df) sebelum memakai fungsi yang ditunjukkan di sini. Cara yang dibuat untuk data frame juga boleh dipakai di data.table tetapi untuk mempercepatkan proses, cara data.table adalah seperti berikut:\n1 2 3 4 5 6 7 8 9 10  library(data.table) DT \u003c- data.table(a=rep(0:1, 5), b=letters[1:10]) val \u003c- c(\"no\", \"yes\") # 0=No, 1=Yes ## Boleh pakai cara biasa levels(DT$a) \u003c- val ## Tukar melalui rujukan tanpa buat salinan setattr(DT$a, \"levels\", c(\"no\", \"yes\"))   Sekiranya ingin membuat salinan di kolom, boleh buat seperti untuk menukarkan kode\n1 2 3 4 5 6 7 8 9 10 11 12 13  DT[.(a = 0:1, new = c(\"no\", \"yes\")), on = \"a\"] a b new 1: 0 a no 2: 0 c no 3: 0 e no 4: 0 g no 5: 0 i no 6: 1 b yes 7: 1 d yes 8: 1 f yes 9: 1 h yes 10: 1 j yes   Cara lain ialah menggunakan fungsi setattr. Tetapi cara ini harus digunakan dengan berhati-hati kerana labels harus tepat dengan jumlah levels.\n1 2 3 4 5 6 7 8 9 10  df3 \u003c- df setDT(df3) ## tukar bandar ke faktor df3[, bandar := as.factor(bandar)] ## tetapkan levels untuk bandar df3[, setattr(x = bandar, name = \"levels\", value = c(\"Tawau\", \"Semporna\", \"Kunak\", \"Lahad Datu\", \"lain-lain\"))]   ","description":"","tags":["faktor"],"title":"Menamakan level di faktor","uri":"/posts/menamakan-level-di-faktor/"},{"categories":["aturcara"],"content":"Kekadang bila buat analisis contohnya dengan menggunakan funksi grep timbul masalah seperti begini:\n1 2 3 4 5 6 7 8 9 10 11 12 13  grep(\"settav\", colnames(regdata), value = TRUE) character(0) Warning messages: 1: In grep(\"settav\", colnames(regdata), value = TRUE) : input string 9 is invalid in this locale 2: In grep(\"settav\", colnames(regdata), value = TRUE) : input string 10 is invalid in this locale 3: In grep(\"settav\", colnames(regdata), value = TRUE) : input string 12 is invalid in this locale 4: In grep(\"settav\", colnames(regdata), value = TRUE) : input string 13 is invalid in this locale 5: In grep(\"settav\", colnames(regdata), value = TRUE) : input string 14 is invalid in this locale   Ini adalah disebabkan oleh penetapan bahasa yang digunakan. Larikan sessionInfo() untuk lihat locale yang terdapat di komputer atau Sys.getlocale() untuk melihat aturcara locale di komputer yang dipakai. Kemudian boleh tukarkan ke bahasa yang dipakai. Aturcara boleh dibace di R manual. Kekadang matikan locale tertentu dengan cara seperti dibawah dapat selesaikan masalah:\n1  Sys.setlocale(locale = \"C\")   Kemudian boleh atifkan semula ke sistem locale default. Pemakaian locale = \"\" untuk menetapkan yang sistem default dipakai.\n1  Sys.setlocale(categories: = \"LC_ALL\", locale = \"\")   Untuk penetapan locale default boleh dibuat di .Rprofile\nBila memakai Linux, Sys.locale boleh di lihat di /etc/default/locale dan jika mahu menukarkan locale di Linux boleh pakai komando seperti ini di shell.\n1 2  sudo locale-gen nb_NO.UTF-8 sudo dpkg-reconfigure locales   ","description":"","tags":["R"],"title":"Masalah locale","uri":"/posts/locale/"},{"categories":["data.table"],"content":"Bila memakai pakej data.table untuk membuat fungsi sebagai kode R, pemilihan kolom boleh dibuat dengan menetapkan nama kolom atau indeks kolom. Akan tetapi pemakaian indeks untuk memilih kolom tidak disarankan kerana ia akan mengakibatkan kode susah untuk difahami. Selain itu sekiranya ada kesilapan kode disebabkan indeks yang merujuk kolom yang tidak diingini, mesej amaran tidak akan diberikan. Oleh itu adalah disarankan untuk memakai nama kolom berbanding indeks kolom.\nWalaubagaimanapun, sekiranya masih ingin memakai indeks kolom juga atas sebab-sebab tertentu, terdapat tiga cara yang boleh dipakai. Baca seterusnya untuk dapatkan penerangan.\nNama kolom Untuk memilih kolom berasaskan nama kolom, boleh memakai get untuk satu kolom atau mget untuk memilih pelbagai kolom (multiple get).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  library(data.table) DT = data.table(A = 1:6, B = 8:3, C = 5:10) ## Cara asas DT[B == 4, ] ## Pakai objek var \u003c- \"B\" value \u003c- 4 DT[get(var) == value, ] ## pilih pelbagai kolom vars \u003c- c(\"A\", \"B\") DT[, mget(vars)] #cara mget   Sekiranya memakai get untuk memilih pelbagai kolom akan hanya menghasilkan vektor kolom pertama dan bukan data.table kolom A dan B.\nIndeks Untuk memilih hanya satu kolom sahaja, caranya:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  library(data.table) DT = data.table(A = 1:6, B = 8:3, C = 5:10) ## pilih kolom 2 (B) yang nilainya bersamaan 4 DT[.(4), on = names(DT)[2]] #cara 1 DT[DT[[2]] == 4] #cara 2 DT[DT[, .I[.SD == 4], .SDcols = 2]] #cara 3 ## sebagai objek var \u003c- 2 value \u003c- 4 DT[.(value), on = names(DT)[var]] #cara 1 DT[DT[[var]] == value] #cara 2 DT[DT[, .I[.SD == value], .SDcols = var]] #cara 3 ## indeks kolom guna fungsi grep atau which vari \u003c- grep(\"B\", colnames(DT)) vari \u003c- which(names(DT) == \"B\") #cara ini lebih laju DT[.(4), on = names(DT)[vari]]   Hasilnya untuk kode-kode di atas adalah seperti ini:\n1 2  A B C 1: 3 4 5   Penggunaan .() di i stuktur data.table DT[i, j, by] adalah alias untuk penggunaan list(). Fungsi ini sama seperti cara 1 di atas.\n1  DT[list(4), on = names(DT)[2]]   Sekiranya ingin pakai index untuk di fungsi by adalah seperti di bawah. Cara ini ialah untuk mengira jumlah huruf-huruf i kolom A.\n1 2 3 4 5 6 7 8 9 10  DT1 \u003c- data.table(A = letters[1:5], B = rep(1:13)) ## dapatkan index kolom menggunakan 'grep' ind \u003c- grep(\"A\", names(DT1)) ## atau menggunakan 'which' ind \u003c- which(names(DT1) == \"A\") ## note - guna 'which' lebih pantas dari 'grep' ## jumlah setiap huruf DT1[, .N, by = DT1[[ind]]]   Hasilnya\n1 2 3 4 5 6  DT1 N 1: a 3 2: b 3 3: c 3 4: d 2 5: e 2   ","description":"","tags":["data.table","indeks","mget","get"],"title":"Pilih kolom cara indeks atau nama kolom","uri":"/posts/kolom-index/"},{"categories":["Markdown"],"content":"Home This page is written in markdown and rendered as html.\nVisit the about page or keep reading.\nOrdered Lists  First Item Next Item Last Item  Unordered Lists  First thing Another thing Last thing  Task Lists  I did this one already Still need to do this one  Quotes One of my favorite quotes is\n “Don’t quote me on that”\n Code Snippets 1 2 3  function deploy(name: string) { console.log(`Deploying ${name}...`); }   Images Hyperlinks Visit ZEIT Now to create your global serverless deployments!\n","description":"","tags":["markdown","world"],"title":"Markdown","uri":"/posts/markdown/"}]
