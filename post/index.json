[
    
        
            {
                "ref": "https://yusbk.github.io/2020/06/15/basic-drake/",
                "title": "Basic use of drake",
                "section": "post",
                "date" : "2020.06.15",
                "body": "There are various ways to organise your R workflow. If you are working with a big project, then Airflow might be for you. But for the majority of R project codes, drake package will fullfilled your need.\nHere is the basic use of drake. The example here will be using a simple collections of functions.\nfun1 \u0026lt;- function(x = globalenv()$x){ x + 2 } fun2 \u0026lt;- function(i = 3){ i * 10 } fun3 \u0026lt;- function(){ x1 = fun1() x2 = fun2(5) x1 + x2 } fun4 \u0026lt;- function(z = globalenv()$z){ x1 = 1 + z x2 = fun2(2) x3 = fun3() x1 + x2 + x3 } Install drake development version in Github here.\nremotes::install_github(\u0026#34;ropensci/drake\u0026#34;) library(drake) x = 3 z = 5 plan \u0026lt;- drake_plan( output = fun4() ) make(plan) Running make(plan) will give the overview what is in the plan, sort of like using Make.\n▶ target x ▶ target z ▶ target output Then you can make the interactive network to see all the workflow. This can be done several ways.\nlibrary(\u0026#34;visNetwork\u0026#34;) vis_drake_graph(plan, full_legend = TRUE) ## need networkD3 package library(networkD3) sankey_drake_graph(plan) library(ggraph) drake_ggraph(plan) ## To show only target and dependency plot(plan) ## read the build target readd(output) This how it looks like using vis_drake_graph. For interactive can be seen here.\n  "
            }
        
    ,
        
            {
                "ref": "https://yusbk.github.io/2020/06/14/git-fork/",
                "title": "git fork",
                "section": "post",
                "date" : "2020.06.14",
                "body": "This is just 100% a copy from gist so I can check it when needed.\nSo you\u0026rsquo;ve cloned somebody\u0026rsquo;s repo from github, but now you want to fork it and contribute back. Never fear!\nTechnically, when you fork \u0026ldquo;origin\u0026rdquo; should be your fork and \u0026ldquo;upstream\u0026rdquo; should be the project you forked; however, if you\u0026rsquo;re willing to break this convention then it\u0026rsquo;s easy.\nOff the top of my head\n Fork their repo on Github In your local, add a new remote to your fork; then fetch it, and push your changes up to it  git remote add my-fork git@github...my-fork.git git fetch my-fork git push my-fork Otherwise, if you want to follow convention:\n Fork their repo on Github In your local, rename your origin remote to upstream  git remote rename origin upstream  Add a new origin  git remote add origin git@github...my-fork  Fetch \u0026amp; push  git fetch origin git push origin "
            }
        
    ,
        
            {
                "ref": "https://yusbk.github.io/2019/01/20/tetapkan-path/",
                "title": "Tetapkan PATH",
                "section": "post",
                "date" : "2019.01.20",
                "body": " Ubuntu Windows  Bila ingin memakai program di Ubuntu atau Windows melalui terminal, perlu daftarkan program tersebut di PATH. Disini saya terangkan caranya di Ubuntu dan Windows.\nUbuntu Bila pasang program di Ubuntu melalui source boleh tetapkan dimana program disimpan melalui penetapkan --prefix bila melarikan ./configure. Cara biasa bila pasang program dari source ialah:\n./configure make make install Bila ./configure tidak menetapkan prefix secara tidak langsung komando yang dipakai ialah ./configure --prefix=/usr/local dimana folder /usr/local dipakai untuk menyimpan fail-fail berkaitan program yang dipasang. Biasanya fail untuk larikan program akan disimpan seterusnya di folder bin, libraries di folder lib, manual di folder man dan seterusnya.\nUntuk tetapkan folder semasa memasng program dari source boleh buat begini:\n./configure --prefix=$HOME/local # atau ./configure --prefix=/home/ybk Bila menetapkan prefix selain dari /usr/local seperti di atas, perlu tetapkan folder tersebut di $PATH agar Ubuntu dapat melarikan program yang ingin dipakai. Untuk periksa folder-folder yang sudah ditetapkan boleh pakai:\n\u0026gt; echo $PATH /home/ybk/.local/bin:/home/ybk/bin:/home/ybk/.local/bin:/usr/local/games:/snap/bin:/usr/local/stata Penetapan folder di $PATH boleh dibuat dengan cara di bawah. Cara ini akan memasukkan PATH di fail /.profile atau /.bashrc.\n\u0026gt; export PATH=\u0026#34;$PATH:/path/folder\u0026#34; Bila melarikan komando export penetapan di $PATH hanya sementara dan hilang bila mematikan komputer. Untuk memasukan folder yang ditetapkan di --prefix ke $PATH selama-lamanya, harus larikan:\nsource ~/.profile # atau source ~/.bashrc Sekiranya tidak menetapkan di $PATH boleh juga menggunakan symlink\nsudo ln -s /path/ke/folder/baru/ ~/bin Windows Cara daftarkan PATH untuk .exe program bergantung samada kita memiliki administrator right atau tidak. Cara yang ditunjukkan disini ialah disituasi tanpa admin right.\nKita boleh lihat semua program-program yang didaftarkan di PATH dengan melarikan arahan di bawah di power shell atau terminal:\necho %PATH% Sekiranya tidak pasti bagimana untuk membuka terminal, tulis di search samada cmd atau powershell.\nKemudian buka control panel [kontrolpanel] \u0026gt; user [brukerkontoer] \u0026gt; environment\rvariable [miljøvariablene]\nWindow baru akan dibuka dan pilih Variable \u0026gt; Path \u0026gt; edit \u0026gt; new.\nMasukkan path program yang menggandungi .exe. Penting tidak memasukkan nama fail .exe, cuma path ke fail tersebut sahaja. Contohnya:\nC:\\Program Files\\R\\R-4.0.0\\bin "
            }
        
    ,
        
            {
                "ref": "https://yusbk.github.io/2017/10/11/susun-factor/",
                "title": "Susun factor",
                "section": "post",
                "date" : "2017.10.11",
                "body": " Susun ketinggian bar Nama di aksis  Bila buat bar plot cara asas di R atau menggunakan pakej ggplot2, susunan levels di x-aksis disusun semula menggikut abjad. Oleh sebab itu sekiranya ingin menyusun mengikut aturcara tertentu, levels di x-aksis harus disusun semula. Pelbagai cara untuk menyusun variable boleh dibuat contohnya menggunakan order (dari \u0026ldquo;base\u0026rdquo;) dan reorder (dari \u0026ldquo;stat\u0026rdquo;). Kedua-dua fungsi ini sudah tersedia di R tanpa perlu memuat turun sebarang pakej.\nCara reorder adalah yang paling mudah tetapi agak lambat berbanding order sekiranya ingin dipakai untuk fungsi di Big Data.\nUntuk memakai cara order dari \u0026ldquo;base\u0026rdquo;. Dengan menggunakan with akan lebih mempercepatkan proses:\nSusun ketinggian bar Cara untuk menyusun bar menaik atau menurun\n## data data \u0026lt;- data.frame(a = LETTERS[1:10], b = rnorm(10, mean = 30, sd = 5), c = runif(10, 10, 50), d = letters[1:10], e = sample(1:100, size = 10, replace = FALSE)) ## susun \u0026#34;a\u0026#34; mengikut nilai \u0026#34;b\u0026#34; menaik data$a \u0026lt;- factor(data$a, levels = data$a[order(data$b)]) ## susun \u0026#34;a\u0026#34; mengikut nilai \u0026#34;b\u0026#34; menurun data$a \u0026lt;- factor(data$a, levels = data$a[order(data$b, decreasing = TRUE)]) ## Buat plot library(ggplot2) data2 \u0026lt;- copy(data) ggplot(data2, aes(a, b)) + geom_bar(stat = \u0026#39;identity\u0026#39;)   Bila menggunakan with, penulisan kode juga akan lebih mudah. Contohnya:\ndata$d \u0026lt;- with(data2, factor(d, levels = d[order(e, decreasing = FALSE)])) Nama di aksis Sekiranya ingin menyusun x-aksis mengikut cara lain selain dari nilai menurun atau menaik melalui pilihan decreasing = TRUE, boleh juga menetapkan susunan cara manual. Bila memakai cara ini harus memberikan nama susunan dengan tepat seperti nama di variable.\n## contoh data data3 \u0026lt;- data.frame(a = LETTERS[1:4], b = sample(20:50, size = 4)) ## Susun cara sendiri data3$a \u0026lt;- factor(data3$a, levels = c(\u0026#34;B\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;)) ## plot ggplot(data3, aes(a, b)) + geom_bar(stat = \u0026#39;identity\u0026#39;)   Untuk memakai cara reorder dari \u0026ldquo;stat\u0026rdquo;:\n## pakai data sama seperti di atas cumpa pakai factor \u0026#34;d\u0026#34; dan nilai \u0026#34;e\u0026#34; data$d \u0026lt;- reorder(data$d, data$e) Cara lain untuk menyusun semula faktor variable menggikut susunan tertentu boleh juga dilaksanakan dengan menggunakan fungsi fct_reorder atau fct_reorder2 dari pakej fotcats yang boleh dibaca di sini. Pakej ini juga ialah sebahagian daripada pakej tidyverse yang mengandungi pakej-pakej lain seperti dplyr dan ggplot2.\n"
            }
        
    ,
        
            {
                "ref": "https://yusbk.github.io/2017/08/31/dt-special-symbol/",
                "title": "special symbol",
                "section": "post",
                "date" : "2017.08.31",
                "body": " .N Mult .SD dan .SDcols .I .GRP dan rleid Contoh dari manual  Hari ni bersempena Hari kemerdekaan Malaysia ada masa untuk ulang kaji pakej data.table. Hari ni ialah mengenai Special Symbol seperti .N, .I, .GRP, .BY. Penerangan ini diambil dari manual di data.table tetapi diedit sedikit. Untuk rujukan di sini.\nIni data yang dipakai untuk membuat contoh:\nDT = data.table(x=rep(c(\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,6,3,7,8), a=1:9, b=9:1) X = data.table(x=c(\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;), v=8:7, foo=c(4,2)) .N Penggunaan .N selain dari untuk mendapatkan jumlah baris di dataset, .N boleh juga digunakan untuk melihat barisan terakhir di dataset. Untuk melihat barisan pertama guna DT[1].\nDT[.N] # last row, only special symbol allowed in \u0026#39;i\u0026#39; - nesten som Total DT[, .N] # total number of rows in DT DT[, .N, by=x] # number of rows in each group Mult Contoh untuk penggunaan mult (multiple rows) adalah seperti di bawah. Penggunaan fungsi mult ialah untuk menetapkan kombinasi barisan yang ingin ditunjukkan samada \u0026ldquo;all\u0026rdquo;, \u0026ldquo;first\u0026rdquo; atau \u0026ldquo;last\u0026rdquo;. Variable x dan y boleh disusun dengan menggunakan setkey(DT, x, y). Sekiranya tidak disusun terlebih dahulu sebelum dipakai maka harus menggunakan fungsi on seperti contoh di bawah.\n## contoh data dt \u0026lt;- data.table(x = c(1, 1, 3, 1, 7), y = c(1, 2, 3, 2, 6)) setkey(dt, x) ## dapatkan kombinasi yang unik udt \u0026lt;- unique(dt) ## buat kolom dengan nilai 0 dt[, c(\u0026#34;first\u0026#34;, \u0026#34;last\u0026#34;) := 0L][] x y first last 1: 1 1 0 0 2: 1 2 0 0 3: 1 2 0 0 4: 3 3 0 0 5: 7 6 0 0 Menggunakan mult untuk menetapkan kombinasi unik yang diingini. Pemakaian \u0026quot;first\u0026quot; menunjukkan kombinasi pertama sahaja. Sekiranya kombinasi yang sama terdapat dipelbagai baris, hanya barisan yang pertama dimana kombinasi tersebut ditemui akan dipilih. Pemakaian \u0026quot;last\u0026quot; memilih barisan terakhir dimana kombinasi yang diingini ditemui.\n## Sekiranya kombinasi x,y yang pertama terdapat ## di data masukkan 1 di kolom \u0026#34;first\u0026#34; dt[udt, first := 1L, on = c(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;), mult = \u0026#34;first\u0026#34;][] ## Sekiranya kombinasi x,y yang terakhir terdapat ## di data masukkan nilai 1 di kolom \u0026#34;last\u0026#34; dt[udt, last := 1L, on = c(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;), mult = \u0026#34;last\u0026#34;][] x y first last 1: 1 1 1 1 2: 1 2 1 0 3: 3 3 1 1 4: 1 2 0 1 5: 7 6 1 1 Contoh di bawah menunjukkan cara sekiranya hanya ingin mendapatkan index kombinasi yang diingini sahaja.\n## Untuk lihat indeks bagi kombinasi yang unik sahaja dt[unique(dt), on = c(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;), mult = \u0026#34;first\u0026#34;, which = TRUE] [1] 1 2 3 5 Contoh lain menggunakan mult. Seperti kajian isi rumah (household) dimana \u0026ldquo;id\u0026rdquo; mewakili rumah. Semua ahli keluarga mempunyai id-rumah sama. Sekiranya ingin mencari ahli termuda atau tertua fungsi mult dapat memudahkan proses.\nset.seed(1234) dt \u0026lt;- data.table(id = sample(1:4, 10, TRUE), umur = sample(20:35, 10, TRUE), jentina = sample(1:2, 10, TRUE), kode = sample(1:5, 2, TRUE)) ## Susun umur mengikut id setkey(dt, id, umur) ## first ialah id yang sama ahli yang paling muda dt[unique(dt), muda := 1L, on = list(id), mult = \u0026#34;first\u0026#34;][] ## Pilih yang terakhir dari id yang sama - cth utk pilih ahli tertua ## sekiranya tidak pakai list di \u0026#39;on = list(nama-var)\u0026#39; boleh pakai \u0026#34;nama-var\u0026#34;. dt[unique(dt), tua := as.integer(1L), on = \u0026#34;id\u0026#34;, mult = \u0026#34;last\u0026#34;, by = .(umur)][] ## pilih nilai pertama untuk setiap kombinasi unik antara \u0026#39;id\u0026#39; dan \u0026#39;kode\u0026#39; dt[unique(dt[, c(\u0026#34;id\u0026#34;, \u0026#34;kode\u0026#34;)]), KodePertama := 1L, on = list(id, kode), mult = \u0026#34;first\u0026#34;][] ## pilih nilai terakhir untuk setiap kombinasi unik antara \u0026#39;id\u0026#39; dan \u0026#39;kode\u0026#39; dt[unique(dt[, c(\u0026#34;id\u0026#34;, \u0026#34;kode\u0026#34;)]), KodeAkhir := 1L, on = c(\u0026#34;id\u0026#34;, \u0026#34;kode\u0026#34;), mult = \u0026#34;last\u0026#34;][] Hasilnya dari contoh pemilihan ahli yang paling muda dan tua dari data di atas menggunakan \u0026quot;first\u0026quot; dan \u0026quot;last\u0026quot;. Pemakaian unique(dt) berasaskan dari penetapan yang dibuat di fungsi setkey dimana data disusun mengikut id kemudian umur terlebih dahulu.\nSekiranya pemilihan kombinasi unik berasaskan kolom lain, selain dari id dan umur yang telah ditetapkan, pemilihan kolom unik boleh dibuat secara fungsi asas menggunakan unique(dt[, c(\u0026quot;kol1\u0026quot;, \u0026quot;kol2\u0026quot;)]). Penggunaan on boleh memakai cara list atau concatenate.\nid umur jentina kode muda tua KodePertama KodeAkhir 1: 1 24 2 3 1 NA 1 NA 2: 1 24 2 2 NA NA 1 1 3: 1 31 1 3 NA 1 NA 1 4: 3 22 2 3 1 NA 1 NA 5: 3 23 1 2 NA NA 1 NA 6: 3 24 1 3 NA NA NA 1 7: 3 28 1 2 NA NA NA NA 8: 3 33 2 2 NA NA NA NA 9: 3 34 1 2 NA 1 NA 1 10: 4 24 1 3 1 1 1 1 .SD dan .SDcols Penggunaan .SD juga boleh berasaskan indeks barisan. Contoh untuk menggunakan .SDcols seperti di bawah termasuk menggunakan fungsi lapply. Tetapi penggunaan \u0026quot;.SD\u0026quot; adalah lebih lambat berbanding menggunakan fungsi \u0026quot;on\u0026quot; seperti di atas.\n# pilih kolom \u0026#39;x\u0026#39; dan \u0026#39;y\u0026#39; DT[, .SD, .SDcols = x:y] # baris pertama di semua kolom DT[, .SD[1]] # baris pertama di \u0026#39;y\u0026#39; dan \u0026#39;v\u0026#39; untuk setiap kumpulan di \u0026#39;x\u0026#39; DT[, .SD[1], by = x] # get rows *and* sum all col DT[, c(.N, lapply(.SD, sum)), by = x] # get rows *and* sum columns \u0026#39;v\u0026#39; and \u0026#39;y\u0026#39; by group DT[, c(.N, lapply(.SD, sum)), by = x, .SDcol = c(\u0026#34;v\u0026#34;, \u0026#34;y\u0026#34;)] .I Untuk dapatkan indeks barisan simbol .I boleh dipakai. Hanya vektor untuk indeks barisan yang akan diberikan dan tidak nilai di indeks tersebut. Fungsinya sama seperti seq_len(nrow(x)). Semasa penggumpulan dibuat, pada masa yang sama penggumpulan dilakukan di dalam kumpulan yang ditetapkan. Sesuai digunakan untuk membuat subset di j seperti: DT[,.I[which.max(somecol)], by=grp]. Penggunaannya same seperti fungsi which di base.\nCara lain boleh digunakan untuk membuat indentity atau ID. DT[, id := .I] seperti menggunakan DT[, id := seq_len(.N)\nPemakaian .I[1] contohny digunakan untuk mendapatkan index dimana nilai pertama bagi setiap kumpulan di x. Untuk kumpulan b di kolom x, nilai pertama ialah di barisan 1, nilai pertama bagi kumpulan a di kolom x ialah di barian ke 4 dan nilai pertama kumpulan c di barisan ke 7.\nDT x v y a b 1: b 1 1 1 9 2: b 1 6 2 8 3: b 1 3 3 7 4: a 2 7 4 6 5: a 2 8 5 5 6: a 1 1 6 4 7: c 1 6 7 3 8: c 2 3 8 2 9: c 2 7 9 1 DT[, .I[1], by = x] # first row number in DT corresponding to each group x V1 1: b 1 2: a 4 3: c 7 DT[, .(index = .I[1]), by = x] # Namakan variable untuk index x index 1: 1 1 2: 3 4 3: 7 5 Untuk dapatkan index bagi nilai maksimum mengikut kumpulan di kolom x boleh dibuat seperti cara di bawah.\nDT[, .I[which.max(y)], by = x] # which row number with the max \u0026#39;y\u0026#39; by \u0026#39;x\u0026#39; x V1 1: b 2 2: a 5 3: c 9 .GRP dan rleid Untuk mengkaji menggikut kumpulan secara penyusunan.\nDT[, grp := .GRP, by = x][] # add a group counter x v y a b grp 1: b 1 1 1 9 1 2: b 1 6 2 8 1 3: b 1 3 3 7 1 4: a 2 7 4 6 2 5: a 2 8 5 5 2 6: a 1 1 6 4 2 7: c 1 6 7 3 3 8: c 2 3 8 2 3 9: c 2 7 9 1 3 DT[, .N, by = rleid(v)] # get count of consecutive runs of \u0026#39;v\u0026#39; rleid N 1: 1 3 2: 2 2 3: 3 2 4: 4 2 DT[, c(.(ym = max(y)), lapply(.SD, min)), by = rleid(v), .SDcols = v:b] # compute \u0026#39;j\u0026#39; for each consecutive runs of \u0026#39;v\u0026#39; rleid ym v y a b 1: 1 6 1 1 1 7 2: 2 8 2 7 4 5 3: 3 6 1 1 6 3 4: 4 7 2 3 8 1 Untuk gabungkan dua dataset. Tapi cara ini masih tidak difahami :-(\nX x v foo 1: c 8 4 2: b 7 2 ## need more info for this X[, DT[.BY, y, on = \u0026#34;x\u0026#34;], by = x] # join within each group x V1 1: c 6 2: c 3 3: c 7 4: b 1 5: b 6 6: b 3 Untuk tukar nilai bagi setiap barisan pertama di kumpulan yang sama. Ini biasanya dipakai contohnya bila membuat kajian keluarga dan ingin memberikan kod tertentu yang membezakan keluarga 1 dan 2 dsb.\nCara ini tidak hard code data. Kolom c tidak dimasukkan ke data dan hanya disimpan di memory sahaja. Untuk simpan harus assign to save object atau gunakan cara mult.\n## Recode to 99 for first row in each group by x DT[, {vDT = copy(.SD) #kopi semua kolom vDT[1, c := 99] #buat kolom C row pertama nilai 99 vDT}, by = x] x v y a b grp c 1: b 1 1 1 9 1 99 2: b 1 6 2 8 1 NA 3: b 1 3 3 7 1 NA 4: a 2 7 4 6 2 99 5: a 2 8 5 5 2 NA 6: a 1 1 6 4 2 NA 7: c 1 6 7 3 3 99 8: c 2 3 8 2 3 NA 9: c 2 7 9 1 3 NA DT[unique(x), d:=99, on = \u0026#34;x\u0026#34;, mult = \u0026#34;first\u0026#34;][] Contoh dari manual Ini ialah contoh dan penerangan dari manual sekiranya penerangan diatas tidak difahami.\n## Not run: DT = data.table(x=rep(c(\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT X = data.table(x=c(\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;), v=8:7, foo=c(4,2)) X DT[.N] # last row, only special symbol allowed in \u0026#39;i\u0026#39; DT[, .N] # total number of rows in DT DT[, .N, by=x] # number of rows in each group DT[, .SD, .SDcols=x:y] # select columns \u0026#39;x\u0026#39; and \u0026#39;y\u0026#39; DT[, .SD[1]] # first row of all columns DT[, .SD[1], by=x] # first row of \u0026#39;y\u0026#39; and \u0026#39;v\u0026#39; for each group in \u0026#39;x\u0026#39; DT[, c(.N, lapply(.SD, sum)), by=x] # get rows *and* sum all columns by group DT[, .I[1], by=x] # row number in DT corresponding to each group starting point DT[, .N, by=rleid(v)] # get count of consecutive runs of \u0026#39;v\u0026#39; DT[, c(.(y=max(y)), lapply(.SD, min)), by=rleid(v), .SDcols=v:b] # compute \u0026#39;j\u0026#39; for each consecutive runs of \u0026#39;v\u0026#39; DT[, grp := .GRP, by=x] # add a group counter X[, DT[.BY, y, on=\u0026#34;x\u0026#34;], by=x] # join within each group ## End(Not run) "
            }
        
    ,
        
            {
                "ref": "https://yusbk.github.io/2020/09/24/git-submodule/",
                "title": "git submodule",
                "section": "post",
                "date" : "2020.09.24",
                "body": "Untuk buat submodule tema harbor\ngit submodule add https://github.com/matsuyoshi30/harbor.git themes/harbor # update git submodule update --remote --merge "
            }
        
    ,
        
            {
                "ref": "https://yusbk.github.io/2017/08/31/test-figure/",
                "title": "Test figure",
                "section": "post",
                "date" : "2017.08.31",
                "body": "Percobaan untuk memasukkan gambar di post dan penetapan size.\n  "
            }
        
    
]